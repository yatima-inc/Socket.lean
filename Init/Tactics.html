<html lang="en">
<head>
<link rel="stylesheet" href="/Socket.lean/style.css"></link><link rel="stylesheet" href="/Socket.lean/pygments.css"></link><link rel="shortcut icon" href="/Socket.lean/favicon.ico"></link><title>Init.Tactics</title>
<meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta></head>
<body>
<input id="nav_toggle" type="checkbox"></input><header>
<h1>
<label for="nav_toggle">
</label>
Documentation</h1>
<p class="header_filename break_within">Init.Tactics</p>
<form action="https://google.com/search" method="get" id="search_form">
<input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib_docs"></input><input type="text" name="q" autocomplete="off"></input><button>Google site search</button>
</form>
</header>
<nav class="internal_nav">
<h3>
<a class="break_within" href="#top">Init.Tactics</a>
</h3>
<p class="gh_nav_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean">source</a>
</p>
<div class="imports">
<details>
<summary>Imports</summary>
<ul>
<li>
<a href="/Socket.lean/Init/Notation.html">Init.Notation</a>
</li>
</ul>
</details>
<details>
<summary>Imported by</summary>
<ul>
<li>
<a href="/Socket.lean/Init.html">Init</a>
</li>
<li>
<a href="/Socket.lean/Init/SizeOf.html">Init.SizeOf</a>
</li>
</ul>
</details>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.withAnnotateState">Lean.Parser.Tactic.withAnnotateState</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.intro">Lean.Parser.Tactic.intro</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.intros">Lean.Parser.Tactic.intros</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rename">Lean.Parser.Tactic.rename</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.revert">Lean.Parser.Tactic.revert</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.clear">Lean.Parser.Tactic.clear</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.subst">Lean.Parser.Tactic.subst</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.apply">Lean.Parser.Tactic.apply</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.exact">Lean.Parser.Tactic.exact</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.refine">Lean.Parser.Tactic.refine</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.refine'">Lean.Parser.Tactic.refine'</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.case">Lean.Parser.Tactic.case</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.case'">Lean.Parser.Tactic.case'</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.«tacticNext___=>_»">Lean.Parser.Tactic.«tacticNext___=>_»</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.allGoals">Lean.Parser.Tactic.allGoals</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.anyGoals">Lean.Parser.Tactic.anyGoals</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.focus">Lean.Parser.Tactic.focus</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.traceMessage">Lean.Parser.Tactic.traceMessage</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.failIfSuccess">Lean.Parser.Tactic.failIfSuccess</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.paren">Lean.Parser.Tactic.paren</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.withReducible">Lean.Parser.Tactic.withReducible</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.withReducibleAndInstances">Lean.Parser.Tactic.withReducibleAndInstances</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.withUnfoldingAll">Lean.Parser.Tactic.withUnfoldingAll</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.first">Lean.Parser.Tactic.first</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rotateLeft">Lean.Parser.Tactic.rotateLeft</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rotateRight">Lean.Parser.Tactic.rotateRight</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticTry_">Lean.Parser.Tactic.tacticTry_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.«tactic_<;>_»">Lean.Parser.Tactic.«tactic_<;>_»</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.refl">Lean.Parser.Tactic.refl</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.ac_refl">Lean.Parser.Tactic.ac_refl</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.locationHyp">Lean.Parser.Tactic.locationHyp</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.change">Lean.Parser.Tactic.change</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.changeWith">Lean.Parser.Tactic.changeWith</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rwRule">Lean.Parser.Tactic.rwRule</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rewriteSeq">Lean.Parser.Tactic.rewriteSeq</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rwSeq">Lean.Parser.Tactic.rwSeq</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.rwWithRfl">Lean.Parser.Tactic.rwWithRfl</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.expandRwSeq">Lean.Parser.Tactic.expandRwSeq</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.injection">Lean.Parser.Tactic.injection</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.injections">Lean.Parser.Tactic.injections</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simp">Lean.Parser.Tactic.simp</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.simpAll">Lean.Parser.Tactic.simpAll</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.dsimp">Lean.Parser.Tactic.dsimp</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.delta">Lean.Parser.Tactic.delta</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.unfold">Lean.Parser.Tactic.unfold</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift_">Lean.Parser.Tactic.tacticRefine_lift_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticHave_">Lean.Parser.Tactic.tacticHave_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.«tacticHave__:=_»">Lean.Parser.Tactic.«tacticHave__:=_»</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticSuffices_">Lean.Parser.Tactic.tacticSuffices_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticLet_">Lean.Parser.Tactic.tacticLet_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticShow_">Lean.Parser.Tactic.tacticShow_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.letrec">Lean.Parser.Tactic.letrec</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticRefine_lift'_">Lean.Parser.Tactic.tacticRefine_lift'_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticHave'_">Lean.Parser.Tactic.tacticHave'_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.«tacticHave'__:=_»">Lean.Parser.Tactic.«tacticHave'__:=_»</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticLet'_">Lean.Parser.Tactic.tacticLet'_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.inductionAltLHS">Lean.Parser.Tactic.inductionAltLHS</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.inductionAlt">Lean.Parser.Tactic.inductionAlt</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.induction">Lean.Parser.Tactic.induction</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.generalizeArg">Lean.Parser.Tactic.generalizeArg</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.generalize">Lean.Parser.Tactic.generalize</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.casesTarget">Lean.Parser.Tactic.casesTarget</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.cases">Lean.Parser.Tactic.cases</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.renameI">Lean.Parser.Tactic.renameI</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticRepeat_">Lean.Parser.Tactic.tacticRepeat_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.split">Lean.Parser.Tactic.split</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.dbgTrace">Lean.Parser.Tactic.dbgTrace</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticStop_">Lean.Parser.Tactic.tacticStop_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.specialize">Lean.Parser.Tactic.specialize</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.tacticUnhygienic_">Lean.Parser.Tactic.tacticUnhygienic_</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.fail">Lean.Parser.Tactic.fail</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.checkpoint">Lean.Parser.Tactic.checkpoint</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.sleep">Lean.Parser.Tactic.sleep</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Tactic.«tacticExists_,,»">Lean.Parser.Tactic.«tacticExists_,,»</a>
</div>
<div class="nav_link">
<a class="break_within" href="#Lean.Parser.Attr.simp">Lean.Parser.Attr.simp</a>
</div>
<div class="nav_link">
<a class="break_within" href="#«term‹_›»">«term‹_›»</a>
</div>
</nav>
<main>
<div class="decl" id="Lean.Parser.Tactic.withAnnotateState">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L12-L13">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">Lean.Parser.Tactic.withAnnotateState</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">Lean.Parser.Tactic.withAnnotateState</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.withAnnotateState</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"with_annotate_state "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`rawStx</span> <span class="fn">0</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ppSpace</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`tactic</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>with_annotate_statestx<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> annotates the lexical range of <code>stx:Syntax</code> with the initial and final state of running tactic <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.intro">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L15-L33">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">Lean.Parser.Tactic.intro</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">Lean.Parser.Tactic.intro</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.intro</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"intro "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`notFollowedBy</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"|"</span></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p>Introduce one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must be a <code>let</code> or function type.</p><ul>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> by itself introduces one anonymous hypothesis, which can be accessed by e.g. <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>x<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">y</a></code> introduces two hypotheses and names them. Individual hypotheses can be anonymized via <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">_</a></code>,
or matched against a pattern:
<pre><code class="language-lean">-- ... ⊢ α × β → ...
intro (a, b)
-- ..., a : α, b : β ⊢ ...
</code></pre>
</li>
<li>Alternatively, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a></code> can be combined with pattern matching much like <code>fun</code>:
<pre><code class="language-lean">intro
| n + 1, 0 => tac
| ...
</code></pre>
</li>
</ul></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.intros">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L34-L35">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intros">Lean.Parser.Tactic.intros</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intros">Lean.Parser.Tactic.intros</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.intros</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"intros "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intros">intros</a>x...</code> behaves like <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>x...</code>, but then keeps introducing (anonymous) hypotheses until goal is not of a function type.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rename">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L36-L39">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rename">Lean.Parser.Tactic.rename</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rename">Lean.Parser.Tactic.rename</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rename</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rename "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" => "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rename">rename</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a>=>x</code> renames the most recent hypothesis whose type matches <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> (which may contain placeholders) to <code>x</code>,
or fails if no such hypothesis could be found.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.revert">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L40-L41">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">Lean.Parser.Tactic.revert</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">Lean.Parser.Tactic.revert</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.revert</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"revert "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">revert</a>x...</code> is the inverse of <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.intro">intro</a>x...</code>: it moves the given hypotheses into the main goal's target type.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.clear">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L42-L43">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">Lean.Parser.Tactic.clear</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">Lean.Parser.Tactic.clear</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.clear</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"clear "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">clear</a>x...</code> removes the given hypotheses, or fails if there are remaining references to a hypothesis.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.subst">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L44-L47">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.subst">Lean.Parser.Tactic.subst</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.subst">Lean.Parser.Tactic.subst</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.subst</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"subst "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a>x...</code> substitutes each <code>x</code> with <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> in the goal if there is a hypothesis of type <code>x=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> or <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>=x</code>.
If <code>x</code> is itself a hypothesis of type <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">y</a>=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> or <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">y</a></code>, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">y</a></code> is substituted instead.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.substVars">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L48-L51">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.substVars">Lean.Parser.Tactic.substVars</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.substVars</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"subst_vars"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p>Apply <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.subst">subst</a></code> to all hypotheses of the form <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:x=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> or <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a>=x</code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.assumption">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L53-L56">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">Lean.Parser.Tactic.assumption</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.assumption</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"assumption"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code> tries to solve the main goal using a hypothesis of compatible type, or else fails.
Note also the <code>‹t›</code> term notation, which is a shorthand for <code>show<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a>by<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.contradiction">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L57-L80">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.contradiction">Lean.Parser.Tactic.contradiction</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.contradiction</span> <span class="fn">1024</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"contradiction"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code> closes the main goal if its hypotheses are "trivially contradictory".</p><ul>
<li>Inductive type/family with no applicable constructors</li>
</ul><pre><code class="language-lean">example (h : False) : p := by contradiction
</code></pre><ul>
<li>Injectivity of constructors</li>
</ul><pre><code class="language-lean">example (h : none = some true) : p := by contradiction  --
</code></pre><ul>
<li>Decidable false proposition</li>
</ul><pre><code class="language-lean">example (h : 2 + 2 = 3) : p := by contradiction
</code></pre><ul>
<li>Contradictory hypotheses</li>
</ul><pre><code class="language-lean">example (h : p) (h' : ¬ p) : q := by contradiction
</code></pre><ul>
<li>Other simple contradictions such as</li>
</ul><pre><code class="language-lean">example (x : Nat) (h : x ≠ x) : p := by contradiction
</code></pre></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.apply">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L81-L89">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">Lean.Parser.Tactic.apply</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">Lean.Parser.Tactic.apply</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.apply</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"apply "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> tries to match the current goal against the conclusion of <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.</p><p>The <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.apply">apply</a></code> tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.exact">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L90-L93">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">Lean.Parser.Tactic.exact</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">Lean.Parser.Tactic.exact</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.exact</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"exact "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> closes the main goal if its target type matches that of <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.refine">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L94-L98">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine">Lean.Parser.Tactic.refine</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine">Lean.Parser.Tactic.refine</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.refine</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"refine "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> behaves like <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>, except that named (<code>?x</code>) or unnamed (<code>?_</code>) holes in <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> that are not solved
by unification with the main goal's target type are converted into new goals, using the hole's name, if any, as the goal case name.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.refine'">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L99-L100">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine'">Lean.Parser.Tactic.refine'</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine'">Lean.Parser.Tactic.refine'</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.refine'</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"refine' "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine'">refine'</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> behaves like <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>, except that unsolved placeholders (<code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">_</a></code>) and implicit parameters are also converted into new goals.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.constructor">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L101-L102">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.constructor">Lean.Parser.Tactic.constructor</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.constructor</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"constructor"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p>If the main goal's target type is an inductive type, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.constructor">constructor</a></code> solves it with the first matching constructor, or else fails.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.case">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L103-L106">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case">Lean.Parser.Tactic.case</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case">Lean.Parser.Tactic.case</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.case</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"case "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" => "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case">case</a>tag=>tac</code> focuses on the goal with case name <code>tag</code> and solves it using <code>tac</code>, or else fails.
<code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case">case</a>tagx₁...xₙ=>tac</code> additionally renames the <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> most recent hypotheses with inaccessible names to the given names.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.case'">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L107-L112">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case'">Lean.Parser.Tactic.case'</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case'">Lean.Parser.Tactic.case'</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.case'</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"case' "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" => "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case'">case'</a></code> is similar to the <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case">case</a>tag=>tac</code> tactic, but does not ensure the goal has been solved after applying <code>tac</code>, nor
admits the goal if <code>tac</code> failed. Recall that <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.case">case</a></code> closes the goal using <code>sorry</code> when <code>tac</code> fails, and
the tactic execution is not interrupted.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.«tacticNext___=>_»">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L114-L117">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticNext___=>_»">Lean.Parser.Tactic.«tacticNext___=>_»</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticNext___=>_»">Lean.Parser.Tactic.«tacticNext___=>_»</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«tacticNext___=>_»</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"next "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" => "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>next=>tac</code> focuses on the next goal solves it using <code>tac</code>, or else fails.
<code>nextx₁...xₙ=>tac</code> additionally renames the <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> most recent hypotheses with inaccessible names to the given names.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.allGoals">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L119-L120">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.allGoals">Lean.Parser.Tactic.allGoals</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.allGoals">Lean.Parser.Tactic.allGoals</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.allGoals</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"all_goals "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>all_goalstac</code> runs <code>tac</code> on each goal, concatenating the resulting goals, if any.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.anyGoals">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L121-L122">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.anyGoals">Lean.Parser.Tactic.anyGoals</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.anyGoals">Lean.Parser.Tactic.anyGoals</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.anyGoals</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"any_goals "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>any_goalstac</code> applies the tactic <code>tac</code> to every goal, and succeeds if at least one application succeeds.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.focus">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L123-L126">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.focus">Lean.Parser.Tactic.focus</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.focus">Lean.Parser.Tactic.focus</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.focus</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"focus "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.focus">focus</a>tac</code> focuses on the main goal, suppressing all other goals, and runs <code>tac</code> on it.
Usually <code>·tac</code>, which enforces that the goal is closed by <code>tac</code>, should be preferred.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.skip">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L127-L128">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">Lean.Parser.Tactic.skip</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.skip</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"skip"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">skip</a></code> does nothing.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.done">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L129-L130">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.done">Lean.Parser.Tactic.done</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.done</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"done"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.done">done</a></code> succeeds iff there are no remaining goals.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.traceState">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L131-L132">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.traceState">Lean.Parser.Tactic.traceState</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.traceState</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"trace_state"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code>trace_state</code> displays the current state in the info view.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.traceMessage">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L133-L134">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.traceMessage">Lean.Parser.Tactic.traceMessage</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.traceMessage">Lean.Parser.Tactic.traceMessage</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.traceMessage</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"trace "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`str</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>tracemsg</code> displays <code>msg</code> in the info view.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.failIfSuccess">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L135-L136">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess">Lean.Parser.Tactic.failIfSuccess</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.failIfSuccess">Lean.Parser.Tactic.failIfSuccess</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.failIfSuccess</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"fail_if_success "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>fail_if_success<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> fails if the tactic <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> succeeds.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.paren">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L137-L137">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.paren">Lean.Parser.Tactic.paren</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.paren">Lean.Parser.Tactic.paren</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.paren</span> <span class="fn">1024</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"("</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">")"</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.withReducible">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L138-L138">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withReducible">Lean.Parser.Tactic.withReducible</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withReducible">Lean.Parser.Tactic.withReducible</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.withReducible</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"with_reducible "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.withReducibleAndInstances">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L139-L139">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances">Lean.Parser.Tactic.withReducibleAndInstances</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withReducibleAndInstances">Lean.Parser.Tactic.withReducibleAndInstances</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.withReducibleAndInstances</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"with_reducible_and_instances "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.withUnfoldingAll">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L140-L140">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">Lean.Parser.Tactic.withUnfoldingAll</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">Lean.Parser.Tactic.withUnfoldingAll</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.withUnfoldingAll</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"with_unfolding_all "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.first">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L141-L142">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.first">Lean.Parser.Tactic.first</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.first">Lean.Parser.Tactic.first</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.first</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"first "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`withPosition</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`group</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGe</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"|"</span></span>)</span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.first">first</a>|tac|...</code> runs each <code>tac</code> until one succeeds, or else fails.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rotateLeft">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L143-L143">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rotateLeft">Lean.Parser.Tactic.rotateLeft</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rotateLeft">Lean.Parser.Tactic.rotateLeft</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rotateLeft</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rotate_left"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`num</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rotateRight">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L144-L144">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rotateRight">Lean.Parser.Tactic.rotateRight</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rotateRight">Lean.Parser.Tactic.rotateRight</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rotateRight</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rotate_right"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`num</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticTry_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L145-L146">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">Lean.Parser.Tactic.tacticTry_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">Lean.Parser.Tactic.tacticTry_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticTry_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"try "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>trytac</code> runs <code>tac</code> and succeeds even if <code>tac</code> failed.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.«tactic_<;>_»">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L147-L148">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»">Lean.Parser.Tactic.«tactic_<;>_»</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tactic_<;>_»">Lean.Parser.Tactic.«tactic_<;>_»</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.trailingNode">Lean.ParserDescr.trailingNode</a> <span class="fn">`Lean.Parser.Tactic.«tactic_<;>_»</span> <span class="fn">1</span> <span class="fn">0</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" <;> "</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`tactic</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>tac<;>tac'</code> runs <code>tac</code> on the main goal and <code>tac'</code> on each produced goal, concatenating all goals produced by <code>tac'</code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.refl">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L155-L156">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refl">Lean.Parser.Tactic.refl</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refl">Lean.Parser.Tactic.refl</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.refl</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"eq_refl"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code>eq_refl</code> is equivalent to <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a><a href="/Socket.lean/Init/Prelude.html#rfl">rfl</a></code>, but has a few optimizations.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticRfl">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L158-L163">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRfl">Lean.Parser.Tactic.tacticRfl</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRfl</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rfl"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Prelude.html#rfl">rfl</a></code> tries to close the current goal using reflexivity.
This is supposed to be an extensible tactic and users can add their own support
for new reflexive relations.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticRfl'">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L165-L168">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRfl'">Lean.Parser.Tactic.tacticRfl'</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRfl'</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rfl'"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code>rfl'</code> is similar to <code><a href="/Socket.lean/Init/Prelude.html#rfl">rfl</a></code>, but disables smart unfolding and unfolds all kinds of definitions,
theorems included (relevant for declarations defined by well-founded recursion).</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.ac_refl">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L170-L170">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.ac_refl">Lean.Parser.Tactic.ac_refl</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.ac_refl">Lean.Parser.Tactic.ac_refl</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.ac_refl</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"ac_refl "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticAdmit">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L172-L173">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticAdmit">Lean.Parser.Tactic.tacticAdmit</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticAdmit</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"admit"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code>admit</code> is a shorthand for <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a>sorry</code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticSorry">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L174-L175">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticSorry">Lean.Parser.Tactic.tacticSorry</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticSorry</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"sorry"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p>The <code>sorry</code> tactic is a shorthand for <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a>sorry</code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticInfer_instance">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L176-L177">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticInfer_instance">Lean.Parser.Tactic.tacticInfer_instance</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticInfer_instance</span> <span class="fn">1024</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"infer_instance"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code>infer_instance</code> is an abbreviation for <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.exact">exact</a><a href="/Socket.lean/Init/Prelude.html#inferInstance">inferInstance</a></code></p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.config">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L179-L180">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"config"</span> <span class="fn">`Lean.Parser.Tactic.config</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`atomic</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"("</span></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"config"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" := "</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">")"</span></span>)</span>)</span></span></li>
</ul>
</details>
<p>Optional configuration option for tactics</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.locationWildcard">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L182-L182">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"locationWildcard"</span> <span class="fn">`Lean.Parser.Tactic.locationWildcard</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"*"</span></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.locationHyp">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L183-L183">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationHyp">Lean.Parser.Tactic.locationHyp</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationHyp">Lean.Parser.Tactic.locationHyp</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"locationHyp"</span> <span class="fn">`Lean.Parser.Tactic.locationHyp</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"⊢"</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"|-"</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.location">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L184-L184">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"location"</span> <span class="fn">`Lean.Parser.Tactic.location</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`withPosition</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" at "</span></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">Lean.Parser.Tactic.locationWildcard</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationHyp">Lean.Parser.Tactic.locationHyp</a></span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.change">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L186-L186">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.change">Lean.Parser.Tactic.change</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.change">Lean.Parser.Tactic.change</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.change</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"change "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.changeWith">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L187-L187">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">Lean.Parser.Tactic.changeWith</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">Lean.Parser.Tactic.changeWith</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.changeWith</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"change "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" with "</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rwRule">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L189-L189">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRule">Lean.Parser.Tactic.rwRule</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRule">Lean.Parser.Tactic.rwRule</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"rwRule"</span> <span class="fn">`Lean.Parser.Tactic.rwRule</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"← "</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"<- "</span></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rwRuleSeq">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L190-L190">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"rwRuleSeq"</span> <span class="fn">`Lean.Parser.Tactic.rwRuleSeq</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"["</span></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy">Lean.ParserDescr.sepBy</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRule">Lean.Parser.Tactic.rwRule</a> <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>) <a href="/Socket.lean/Init/Prelude.html#Bool.true">true</a></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"]"</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rewriteSeq">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L192-L199">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq">Lean.Parser.Tactic.rewriteSeq</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rewriteSeq">Lean.Parser.Tactic.rewriteSeq</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rewriteSeq</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rewrite "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></span>)</span>)
        <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>rewrite[e]</code> applies identity <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> as a rewrite rule to the target of the main goal.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is preceded by left arrow (<code>←</code> or <code><-</code>), the rewrite is applied in the reverse direction.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is a defined constant, then the equational theorems associated with <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> are used. This provides a convenient way to unfold <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>.</p><ul>
<li><code>rewrite[e₁,...,eₙ]</code> applies the given rules sequentially.</li>
<li><code>rewrite[e]at<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">l</a></code> rewrites <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> at location(s) <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">l</a></code>, where <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withUnfoldingAll">l</a></code> is either <code>*</code> or a list of hypotheses in the local context. In the latter case, a turnstile <code>⊢</code> or <code>|-</code> can also be used, to signify the target of the goal.</li>
</ul></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rwSeq">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L201-L204">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwSeq">Lean.Parser.Tactic.rwSeq</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwSeq">Lean.Parser.Tactic.rwSeq</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.rwSeq</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rw "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></span>)</span>)
        <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">Lean.Parser.Tactic.rwRuleSeq</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>rw</code> is like <code>rewrite</code>, but also tries to close the goal by "cheap" (reducible) <code><a href="/Socket.lean/Init/Prelude.html#rfl">rfl</a></code> afterwards.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.rwWithRfl">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L206-L213">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwWithRfl">Lean.Parser.Tactic.rwWithRfl</a>
</span>
<span class="decl_args">
<span class="fn">(kind : <a href="/Socket.lean/Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(atom : <a href="/Socket.lean/Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(stx : <a href="/Socket.lean/Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">:</span>
<div class="decl_type"><span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href="/Socket.lean/Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwWithRfl">Lean.Parser.Tactic.rwWithRfl</a> <span class="fn">kind</span> <span class="fn">atom</span> <span class="fn">stx</span></span> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn">let seq := <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.getOp">Lean.Syntax.getOp</a> <span class="fn">stx</span> <span class="fn">2</span></span>;
  <span class="fn">let rbrak := <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.getOp">Lean.Syntax.getOp</a> <span class="fn">seq</span> <span class="fn">2</span></span>;
  <span class="fn">let seq := <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.setArg">Lean.Syntax.setArg</a> <span class="fn">seq</span> <span class="fn">2</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.mkAtom">Lean.mkAtom</a> <span class="fn">"]"</span></span>)</span>;
  <span class="fn">let tac := <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.setArg">Lean.Syntax.setArg</a> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.setArg">Lean.Syntax.setArg</a> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.setKind">Lean.Syntax.setKind</a> <span class="fn">stx</span> <span class="fn">kind</span></span>) <span class="fn">0</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.mkAtomFrom">Lean.mkAtomFrom</a> <span class="fn">stx</span> <span class="fn">atom</span></span>)</span>) <span class="fn">2</span> <span class="fn">seq</span></span>;
  <span class="fn">do
  let info ← <span class="fn">Lean.MonadRef.mkInfoFromRefPos</span>
  let _ ← <span class="fn">Lean.getCurrMacroScope</span>
  let _ ← <span class="fn">Lean.getMainModule</span>
  <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Pure.pure">pure</a>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.seq1</span>
        <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span>
            <span class="fn">#[<span class="fn">tac</span>, <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">";"</span></span>,
              <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.tacticTry_</span>
                <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">"try"</span></span>,
                  <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.tacticSeq</span>
                    <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.tacticSeq1Indented</span>
                        <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span>
                            <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`group</span>
                                <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.paren</span>
                                    <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">"("</span></span>,
                                      <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.tacticSeq</span>
                                        <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`Lean.Parser.Tactic.tacticSeq1Indented</span>
                                            <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span>
                                                <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`group</span>
                                                    <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a>
                                                        <span class="fn">`Lean.Parser.Tactic.withReducible</span>
                                                        <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">"with_reducible"</span></span>,
                                                          <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a>
                                                            <span class="fn">`Lean.Parser.Tactic.tacticSeq</span>
                                                            <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a>
                                                                <span class="fn">`Lean.Parser.Tactic.tacticSeq1Indented</span>
                                                                <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span>
                                                                    <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`group</span>
                                                                        <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a>
                                                                            <span class="fn">`Lean.Parser.Tactic.tacticRfl</span>
                                                                            <span class="fn">#[<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a>
                                                                                (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Option.getD">Option.getD</a>
                                                                                  (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.getHeadInfo?">Lean.Syntax.getHeadInfo?</a> <span class="fn">rbrak</span></span>) <span class="fn">info</span></span>)
                                                                                <span class="fn">"rfl"</span></span>]</span></span>,
                                                                          <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span>
                                                                            <span class="fn">#[]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>,
                                                      <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span> <span class="fn">#[]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>,
                                      <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <span class="fn">info</span> <span class="fn">")"</span></span>]</span></span>,
                                  <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <a href="/Socket.lean/Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">`null</span> <span class="fn">#[]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>]</span></span>)</span></span></span></span></span></span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.expandRwSeq">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L215-L216">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.expandRwSeq">Lean.Parser.Tactic.expandRwSeq</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.Macro">Lean.Macro</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.expandRwSeq">Lean.Parser.Tactic.expandRwSeq</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a> <span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwWithRfl">Lean.Parser.Tactic.rwWithRfl</a> <span class="fn">`Lean.Parser.Tactic.rewriteSeq</span> <span class="fn">"rewrite"</span></span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.injection">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L218-L227">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injection">Lean.Parser.Tactic.injection</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injection">Lean.Parser.Tactic.injection</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.injection</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"injection "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" with "</span></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p>The <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a></code> tactic is based on the fact that constructors of inductive data types are injections.
That means that if <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.letrec">c</a></code> is a constructor of an inductive datatype, and if <code>(ct₁)</code> and <code>(ct₂)</code> are two terms that are equal then  <code>t₁</code> and <code>t₂</code> are equal too.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">q</a></code> is a proof of a statement of conclusion <code>t₁=t₂</code>, then injection applies injectivity to derive the equality of all arguments of <code>t₁</code> and <code>t₂</code>
placed in the same positions. For example, from <code>(a::b)=(c::d)</code> we derive <code>a=c</code> and <code>b=d</code>. To use this tactic <code>t₁</code> and <code>t₂</code>
should be constructor applications of the same constructor.
Given <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:a::b=c::d</code>, the tactic <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a></code> adds two new hypothesis with types <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a>=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.letrec">c</a></code> and <code>b=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.locationWildcard">d</a></code> to the main goal.
The tactic <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injection">injection</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>withh₁h₂</code> uses the names <code>h₁</code> and <code>h₂</code> to name the new hypotheses.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.injections">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L229-L229">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injections">Lean.Parser.Tactic.injections</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.injections">Lean.Parser.Tactic.injections</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.injections</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"injections"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.discharger">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L231-L231">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"discharger"</span> <span class="fn">`Lean.Parser.Tactic.discharger</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`atomic</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"("</span></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"discharger"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
                (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"disch"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" := "</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">")"</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simpPre">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L233-L233">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"simpPre"</span> <span class="fn">`Lean.Parser.Tactic.simpPre</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"↓"</span></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simpPost">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L234-L234">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"simpPost"</span> <span class="fn">`Lean.Parser.Tactic.simpPost</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"↑"</span></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simpLemma">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L235-L235">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"simpLemma"</span> <span class="fn">`Lean.Parser.Tactic.simpLemma</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"← "</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"<- "</span></span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simpErase">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L236-L236">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"simpErase"</span> <span class="fn">`Lean.Parser.Tactic.simpErase</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"-"</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simpStar">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L237-L237">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"simpStar"</span> <span class="fn">`Lean.Parser.Tactic.simpStar</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"*"</span></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simp">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L238-L249">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">Lean.Parser.Tactic.simp</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">Lean.Parser.Tactic.simp</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.simp</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"simp "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></span>)</span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a></span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"only "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"["</span></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy">Lean.ParserDescr.sepBy</a>
                (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpStar">Lean.Parser.Tactic.simpStar</a>
                  (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a></span>)</span>)
                <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"]"</span></span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p>The <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.</p><ul>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> simplifies the main goal target using lemmas tagged with the attribute <code>[simp]</code>.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>[h₁,h₂,...,hₙ]</code> simplifies the main goal target using the lemmas tagged with the attribute <code>[simp]</code> and the given <code>hᵢ</code>'s, where the <code>hᵢ</code>'s are expressions. If an <code>hᵢ</code> is a defined constant <code>f</code>, then the equational lemmas associated with <code>f</code> are used. This provides a convenient way to unfold <code>f</code>.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>[*]</code> simplifies the main goal target using the lemmas tagged with the attribute <code>[simp]</code> and all hypotheses.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>only[h₁,h₂,...,hₙ]</code> is like <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>[h₁,h₂,...,hₙ]</code> but does not use <code>[simp]</code> lemmas</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>[-id₁,...,-idₙ]</code> simplifies the main goal target using the lemmas tagged with the attribute <code>[simp]</code>, but removes the ones named <code>idᵢ</code>.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>ath₁h₂...hₙ</code> simplifies the hypotheses <code>h₁:T₁</code> ... <code>hₙ:Tₙ</code>. If the target or another hypothesis depends on <code>hᵢ</code>, a new simplified hypothesis <code>hᵢ</code> is introduced, but the old one remains in the local context.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>at*</code> simplifies all the hypotheses and the target.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>[*]at*</code> simplifies target and all (propositional) hypotheses using the other hypotheses.</li>
</ul></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.simpAll">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L250-L255">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpAll">Lean.Parser.Tactic.simpAll</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpAll">Lean.Parser.Tactic.simpAll</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.simpAll</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"simp_all "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"only "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"["</span></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy">Lean.ParserDescr.sepBy</a>
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a></span>) <span class="fn">","</span>
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"]"</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code>simp_all</code> is a stronger version of <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a>[*]at*</code> where the hypotheses and target are simplified
multiple times until no simplication is applicable.
Only non-dependent propositional hypotheses are considered.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.dsimp">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L257-L261">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.dsimp">Lean.Parser.Tactic.dsimp</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.dsimp">Lean.Parser.Tactic.dsimp</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.dsimp</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"dsimp "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.config">Lean.Parser.Tactic.config</a></span>)</span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.discharger">Lean.Parser.Tactic.discharger</a></span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"only "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"["</span></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy">Lean.ParserDescr.sepBy</a>
                (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpErase">Lean.Parser.Tactic.simpErase</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">Lean.Parser.Tactic.simpLemma</a></span>) <span class="fn">","</span>
                (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"]"</span></span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p>The <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.dsimp">dsimp</a></code> tactic is the definitional simplifier. It is similar to <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simp">simp</a></code> but only applies theorems that hold by
reflexivity. Thus, the result is guaranteed to be definitionally equal to the input.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.delta">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L263-L266">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.delta">Lean.Parser.Tactic.delta</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.delta">Lean.Parser.Tactic.delta</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.delta</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"delta "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a><a href="/Socket.lean/Init/Prelude.html#id">id</a></code> delta-expands the definition <code><a href="/Socket.lean/Init/Prelude.html#id">id</a></code>.
This is a low-level tactic, it will expose how recursive definitions have been compiled by Lean.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.unfold">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L267-L271">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.unfold">Lean.Parser.Tactic.unfold</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.unfold">Lean.Parser.Tactic.unfold</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.unfold</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"unfold "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy1">Lean.ParserDescr.sepBy1</a> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.unfold">unfold</a>id,+</code> unfolds definition <code><a href="/Socket.lean/Init/Prelude.html#id">id</a></code>. For non-recursive definitions, this tactic is identical to <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.delta">delta</a></code>.
For recursive definitions, it hides the encoding tricks used by the Lean frontend to convince the
kernel that the definition terminates.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L275-L275">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_">Lean.Parser.Tactic.tacticRefine_lift_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift_">Lean.Parser.Tactic.tacticRefine_lift_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRefine_lift_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"refine_lift "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticHave_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L277-L283">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticHave_">Lean.Parser.Tactic.tacticHave_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticHave_">Lean.Parser.Tactic.tacticHave_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticHave_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"have "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`haveDecl</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>have<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a>:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> adds the hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> to the current goal if <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> a term of type <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>. If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> is omitted, it will be inferred.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a></code> is omitted, the name <code>this</code> is used.
The variant <code>havepattern:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is equivalent to <code>match<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>with|pattern=><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">_</a></code>, and it is convenient for types that have only applicable constructor.
Example: given <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">p</a>∧<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">q</a>∧<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">r</a></code>, <code>have⟨h₁,h₂,h₃⟩:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a></code> produces the hypotheses <code>h₁:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">p</a></code>, <code>h₂:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">q</a></code>, and <code>h₃:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">r</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.«tacticHave__:=_»">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L285-L288">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticHave__:=_»">Lean.Parser.Tactic.«tacticHave__:=_»</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticHave__:=_»">Lean.Parser.Tactic.«tacticHave__:=_»</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«tacticHave__:=_»</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"have"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" := "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>have<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> adds the hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> if <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticSuffices_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L289-L296">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_">Lean.Parser.Tactic.tacticSuffices_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticSuffices_">Lean.Parser.Tactic.tacticSuffices_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticSuffices_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"suffices "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`sufficesDecl</span></span>)</span>)</span></span></li>
</ul>
</details>
<p>Given a main goal <code>ctx|-<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>, <code>suffices<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:t'from<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> replaces the main goal with <code>ctx|-t'</code>,
<code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> must have type <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> in the context <code>ctx,<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:t'</code>.</p><p>The variant <code>suffices<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:t'bytac</code> is a shorthand for <code>suffices<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:t'frombytac</code>.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:</code> is omitted, the name <code>this</code> is used.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticLet_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L297-L303">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticLet_">Lean.Parser.Tactic.tacticLet_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticLet_">Lean.Parser.Tactic.tacticLet_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticLet_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"let "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`letDecl</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>let<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a>:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> adds the hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a>:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> to the current goal if <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> a term of type <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> is omitted, it will be inferred.
The variant <code>letpattern:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is equivalent to <code>match<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>with|pattern=><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTry_">_</a></code>, and it is convenient for types that have only applicable constructor.
Example: given <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">p</a>∧<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">q</a>∧<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">r</a></code>, <code>let⟨h₁,h₂,h₃⟩:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a></code> produces the hypotheses <code>h₁:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.skip">p</a></code>, <code>h₂:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.rwRuleSeq">q</a></code>, and <code>h₃:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">r</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticShow_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L304-L308">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticShow_">Lean.Parser.Tactic.tacticShow_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticShow_">Lean.Parser.Tactic.tacticShow_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticShow_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"show "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>show<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> finds the first goal whose target unifies with <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>. It makes that the main goal,
performs the unification, and replaces the target with the unified version of <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.letrec">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L309-L309">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.letrec">Lean.Parser.Tactic.letrec</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.letrec">Lean.Parser.Tactic.letrec</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.letrec</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`withPosition</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`atomic</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`group</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"let "</span></span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rec "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`letRecDecls</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticRefine_lift'_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L314-L314">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_">Lean.Parser.Tactic.tacticRefine_lift'_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRefine_lift'_">Lean.Parser.Tactic.tacticRefine_lift'_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRefine_lift'_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"refine_lift' "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticHave'_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L315-L315">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_">Lean.Parser.Tactic.tacticHave'_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticHave'_">Lean.Parser.Tactic.tacticHave'_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticHave'_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"have' "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`haveDecl</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.«tacticHave'__:=_»">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L316-L316">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'__:=_»">Lean.Parser.Tactic.«tacticHave'__:=_»</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticHave'__:=_»">Lean.Parser.Tactic.«tacticHave'__:=_»</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«tacticHave'__:=_»</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"have'"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" := "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticLet'_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L317-L317">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_">Lean.Parser.Tactic.tacticLet'_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticLet'_">Lean.Parser.Tactic.tacticLet'_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticLet'_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"let' "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`letDecl</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.inductionAltLHS">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L319-L319">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS">Lean.Parser.Tactic.inductionAltLHS</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS">Lean.Parser.Tactic.inductionAltLHS</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"inductionAltLHS"</span> <span class="fn">`Lean.Parser.Tactic.inductionAltLHS</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"| "</span></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`group</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"@"</span></span>)</span>)
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.inductionAlt">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L320-L320">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlt">Lean.Parser.Tactic.inductionAlt</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlt">Lean.Parser.Tactic.inductionAlt</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"inductionAlt"</span> <span class="fn">`Lean.Parser.Tactic.inductionAlt</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`ppDedent</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ppLine</span></span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAltLHS">Lean.Parser.Tactic.inductionAltLHS</a></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" => "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`hole</span></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`syntheticHole</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.inductionAlts">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L321-L321">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"inductionAlts"</span> <span class="fn">`Lean.Parser.Tactic.inductionAlts</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"with "</span></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`tactic</span> <span class="fn">0</span></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`withPosition</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGe</span></span>) <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlt">Lean.Parser.Tactic.inductionAlt</a></span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.induction">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L322-L336">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">Lean.Parser.Tactic.induction</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">Lean.Parser.Tactic.induction</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.induction</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"induction "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy1">Lean.ParserDescr.sepBy1</a> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>) <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" using "</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"generalizing "</span></span>)
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">1024</span></span>)</span>)</span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a></span>)</span>)</span></span></li>
</ul>
</details>
<p>Assuming <code>x</code> is a variable in the local context with an inductive type, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a>x</code> applies induction on <code>x</code> to the main goal,
producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on <code>x</code>, that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.
For example, given <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a>:<a href="/Socket.lean/Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:P<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> and target <code>Q<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code>, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> produces one goal
with hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:P0</code> and target <code>Q0</code>, and one goal with hypotheses <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:P(Nat.succa)</code> and <code>ih₁:P<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a>→Q<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a></code> and target <code>Q(Nat.succa)</code>.
Here the names <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a></code> and <code>ih₁</code> are chosen automatically and are not accessible. You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>, where <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is an expression instead of a variable, generalizes <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> in the goal, and then performs induction on the resulting variable.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>using<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">r</a></code> allows the user to specify the principle of induction that should be used. Here <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.clear">r</a></code> should be a theorem whose result type must be of the form <code>C<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>, where <code>C</code> is a bound variable and <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> is a (possibly empty) sequence of bound variables</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>generalizingz₁...zₙ</code>, where <code>z₁...zₙ</code> are variables in the local context, generalizes over <code>z₁...zₙ</code> before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.</li>
<li>Given <code>x:<a href="/Socket.lean/Init/Prelude.html#Nat">Nat</a></code>, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.induction">induction</a>xwith|zero=>tac₁|succx'ih=>tac₂</code> uses tactic <code>tac₁</code> for the <code>zero</code> case, and <code>tac₂</code> for the <code>succ</code> case.</li>
</ul></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.generalizeArg">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L338-L338">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.generalizeArg">Lean.Parser.Tactic.generalizeArg</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.generalizeArg">Lean.Parser.Tactic.generalizeArg</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"generalizeArg"</span> <span class="fn">`Lean.Parser.Tactic.generalizeArg</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
            (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`atomic</span>
              (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" : "</span></span>)</span>)</span>)</span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">51</span></span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" = "</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.generalize">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L339-L342">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.generalize">Lean.Parser.Tactic.generalize</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.generalize">Lean.Parser.Tactic.generalize</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.generalize</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"generalize "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy1">Lean.ParserDescr.sepBy1</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.generalizeArg">Lean.Parser.Tactic.generalizeArg</a> <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.generalize">generalize</a>([h:]<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>=x),+</code> replaces all occurrences <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>s in the main goal with a fresh hypothesis <code>x</code>s.
If <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a></code> is given, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>=x</code> is introduced as well.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.casesTarget">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L344-L344">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.casesTarget">Lean.Parser.Tactic.casesTarget</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.casesTarget">Lean.Parser.Tactic.casesTarget</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nodeWithAntiquot">Lean.ParserDescr.nodeWithAntiquot</a> <span class="fn">"casesTarget"</span> <span class="fn">`Lean.Parser.Tactic.casesTarget</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`atomic</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" : "</span></span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.cases">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L345-L356">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">Lean.Parser.Tactic.cases</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">Lean.Parser.Tactic.cases</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.cases</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"cases "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy1">Lean.ParserDescr.sepBy1</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.casesTarget">Lean.Parser.Tactic.casesTarget</a> <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">" using "</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.inductionAlts">Lean.Parser.Tactic.inductionAlts</a></span>)</span>)</span></span></li>
</ul>
</details>
<p>Assuming <code>x</code> is a variable in the local context with an inductive type, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a>x</code> splits the main goal,
producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.
If the type of an element in the local context depends on <code>x</code>, that element is reverted and reintroduced afterward,
so that the case split affects that hypothesis as well. <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a></code> detects unreachable cases and closes them automatically.
For example, given <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a>:<a href="/Socket.lean/Init/Prelude.html#Nat">Nat</a></code> and a goal with a hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:P<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> and target <code>Q<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code>, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> produces one goal with hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:P0</code> and target <code>Q0</code>,
and one goal with hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:P(Nat.succa)</code> and target <code>Q(Nat.succa)</code>. Here the name <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a></code> is chosen automatically and are not accessible. You can use <code>with</code> to provide the variables names for each constructor.</p><ul>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>, where <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is an expression instead of a variable, generalizes <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> in the goal, and then cases on the resulting variable.</li>
<li>Given <code>as:<a href="/Socket.lean/Init/Prelude.html#List">List</a>α</code>, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a>aswith|nil=>tac₁|cons<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a>as'=>tac₂</code>, uses tactic <code>tac₁</code> for the <code>nil</code> case, and <code>tac₂</code> for the <code>cons</code> case, and <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpLemma">a</a></code> and <code>as'</code> are used as names for the new variables introduced.</li>
<li><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.cases">cases</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code>, where <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> is a variable or an expression, performs cases on <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a></code> as above, but also adds a hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.withAnnotateState">e</a>=...</code> to each hypothesis, where <code>...</code> is the constructor instance for that particular case.</li>
</ul></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.renameI">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L358-L359">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.renameI">Lean.Parser.Tactic.renameI</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.renameI">Lean.Parser.Tactic.renameI</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.renameI</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"rename_i "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`many1</span>
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>)
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`ident</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"_"</span></span>)</span>)</span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code>rename_ix_1...x_n</code> renames the last <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> inaccessible names using the given names.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticRepeat_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L361-L365">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_">Lean.Parser.Tactic.tacticRepeat_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticRepeat_">Lean.Parser.Tactic.tacticRepeat_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticRepeat_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"repeat "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>repeattac</code> applies <code>tac</code> to main goal. If the application succeeds,
the tactic is applied recursively to the generated subgoals until it eventually fails.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticTrivial">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L369-L376">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticTrivial">Lean.Parser.Tactic.tacticTrivial</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticTrivial</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"trivial"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Core.html#trivial">trivial</a></code> tries different simple tactics (e.g., <code><a href="/Socket.lean/Init/Prelude.html#rfl">rfl</a></code>, <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.contradiction">contradiction</a></code>, ...) to close the current goal.
You can use the command <code>macro_rules</code> to extend the set of tactics used. Example:</p><pre><code>macro_rules | `(tactic| trivial) => `(tactic| simp)
</code></pre></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.split">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L378-L382">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.split">Lean.Parser.Tactic.split</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.split">Lean.Parser.Tactic.split</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.split</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"split "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`colGt</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.location">Lean.Parser.Tactic.location</a></span>)</span>)</span></span></li>
</ul>
</details>
<p>The <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic is useful for breaking nested if-then-else and match expressions in cases.
For a <code>match</code> expression with <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> cases, the <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.split">split</a></code> tactic generates at most <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">n</a></code> subgoals</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.dbgTrace">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L384-L384">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.dbgTrace">Lean.Parser.Tactic.dbgTrace</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.dbgTrace">Lean.Parser.Tactic.dbgTrace</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.dbgTrace</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"dbg_trace "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`str</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticStop_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L386-L388">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticStop_">Lean.Parser.Tactic.tacticStop_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticStop_">Lean.Parser.Tactic.tacticStop_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticStop_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"stop"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`group</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code>stop</code> is a helper tactic for "discarding" the rest of a proof. It is useful when working on the middle of a complex proofs,
and less messy than commenting the remainder of the proof.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.specialize">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L390-L396">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.specialize">Lean.Parser.Tactic.specialize</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.specialize">Lean.Parser.Tactic.specialize</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.specialize</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"specialize "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)</span></span></li>
</ul>
</details>
<p>The tactic <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.specialize">specialize</a><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>a₁...aₙ</code> works on local hypothesis <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a></code>.
The premises of this hypothesis, either universal quantifications or non-dependent implications,
are instantiated by concrete terms coming either from arguments <code>a₁</code> ... <code>aₙ</code>.
The tactic adds a new hypothesis with the same name <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>:=<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.changeWith">h</a>a₁...aₙ</code> and tries to clear the previous one.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.tacticUnhygienic_">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L405-L405">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_">Lean.Parser.Tactic.tacticUnhygienic_</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.tacticUnhygienic_">Lean.Parser.Tactic.tacticUnhygienic_</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.tacticUnhygienic_</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"unhygienic "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.fail">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L407-L408">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.fail">Lean.Parser.Tactic.fail</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.fail">Lean.Parser.Tactic.fail</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.fail</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"fail "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`str</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.fail">fail</a>msg</code> is a tactic that always fail and produces an error using the given message.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.checkpoint">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L410-L410">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.checkpoint">Lean.Parser.Tactic.checkpoint</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.checkpoint">Lean.Parser.Tactic.checkpoint</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.checkpoint</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"checkpoint "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`tacticSeq</span></span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.save">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L412-L412">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.save">Lean.Parser.Tactic.save</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.save</span> <span class="fn">1024</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"save"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="Lean.Parser.Tactic.sleep">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L414-L415">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.sleep">Lean.Parser.Tactic.sleep</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.sleep">Lean.Parser.Tactic.sleep</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.sleep</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"sleep"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.const">Lean.ParserDescr.const</a> <span class="fn">`num</span></span>)</span>)</span></span></li>
</ul>
</details>
<p>The tactic <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.sleep">sleep</a>ms</code> sleeps for <code>ms</code> milliseconds and does nothing. It is used for debugging purposes only.</p></div>
</div>
<div class="decl" id="Lean.Parser.Tactic.«tacticExists_,,»">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L417-L419">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»">Lean.Parser.Tactic.«tacticExists_,,»</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.«tacticExists_,,»">Lean.Parser.Tactic.«tacticExists_,,»</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Tactic.«tacticExists_,,»</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"exists "</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.sepBy1">Lean.ParserDescr.sepBy1</a> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>) <span class="fn">","</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">", "</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
<p><code>existse₁,e₂,...</code> is shorthand for <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.refine">refine</a>⟨e₁,e₂,...⟩;try<a href="/Socket.lean/Init/Core.html#trivial">trivial</a></code>. It is useful for existential goals.</p></div>
</div>
<div class="decl" id="Lean.Parser.Attr.simp">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L425-L425">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#Lean.Parser.Attr.simp">Lean.Parser.Attr.simp</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Attr.simp">Lean.Parser.Attr.simp</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`Lean.Parser.Attr.simp</span> <span class="fn">1022</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.nonReservedSymbol">Lean.ParserDescr.nonReservedSymbol</a> <span class="fn">"simp"</span> <a href="/Socket.lean/Init/Prelude.html#Bool.false">false</a></span>)
        (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span>
          (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`orelse</span> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPre">Lean.Parser.Tactic.simpPre</a> <a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.simpPost">Lean.Parser.Tactic.simpPost</a></span>)</span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.unary">Lean.ParserDescr.unary</a> <span class="fn">`optional</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`prio</span> <span class="fn">0</span></span>)</span>)</span>)</span></span></li>
</ul>
</details>
</div>
</div>
<div class="decl" id="«term‹_›»">
<div class="def">
<div class="gh_link">
<a href="https://github.com/leanprover/lean4/blob/6b1297fe85575c91cf613640bdd96cd1241d1a9e/src/Init/Tactics.lean#L431-L434">source</a>
</div>
<div class="decl_header">
<span class="decl_kind">def</span>
<span class="decl_name">
<a class="break_within" href="/Socket.lean/Init/Tactics.html#«term‹_›»">«term‹_›»</a>
</span>
<span class="decl_args">:</span>
<div class="decl_type"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></div></div>
<details>
<summary>Equations</summary>
<ul class="equations">
<li class="equation">
<span class="fn"><a href="/Socket.lean/Init/Tactics.html#«term‹_›»">«term‹_›»</a> <a href="/Socket.lean/Init/Prelude.html#Eq">=</a>   <span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.node">Lean.ParserDescr.node</a> <span class="fn">`«term‹_›»</span> <span class="fn">1024</span>
    (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span>
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.binary">Lean.ParserDescr.binary</a> <span class="fn">`andthen</span> (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"‹"</span></span>) (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.cat">Lean.ParserDescr.cat</a> <span class="fn">`term</span> <span class="fn">0</span></span>)</span>)
      (<span class="fn"><a href="/Socket.lean/Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">"›"</span></span>)</span>)</span></span></li>
</ul>
</details>
<p><code>‹t›</code> resolves to an (arbitrary) hypothesis of type <code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code>. It is useful for referring to hypotheses without accessible names.
<code><a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.revert">t</a></code> may contain holes that are solved by unification with the expected type; in particular, <code>‹_›</code> is a shortcut for <code>by<a href="/Socket.lean/Init/Tactics.html#Lean.Parser.Tactic.assumption">assumption</a></code>.</p></div>
</div>
</main>
<nav class="nav">
<h3>General documentation</h3>
<div class="nav_link">
<a href="/Socket.lean/">index</a>
</div>
<h3>Library</h3>
<div class="module_list">
<details class="nav_sect" data-path="/Socket.lean/Init.html" open="">
<summary>Init</summary>
<details class="nav_sect" data-path="/Socket.lean/Init/Control.html">
<summary>Init.Control</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/Basic.html">Init.Control.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/EState.html">Init.Control.EState</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/Except.html">Init.Control.Except</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/ExceptCps.html">Init.Control.ExceptCps</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/Id.html">Init.Control.Id</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/Lawful.html">Init.Control.Lawful</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/Option.html">Init.Control.Option</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/Reader.html">Init.Control.Reader</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/State.html">Init.Control.State</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/StateCps.html">Init.Control.StateCps</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control/StateRef.html">Init.Control.StateRef</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data.html">
<summary>Init.Data</summary>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Array.html">
<summary>Init.Data.Array</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/Basic.html">Init.Data.Array.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/BasicAux.html">Init.Data.Array.BasicAux</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/BinSearch.html">Init.Data.Array.BinSearch</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/DecidableEq.html">Init.Data.Array.DecidableEq</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/InsertionSort.html">Init.Data.Array.InsertionSort</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/Mem.html">Init.Data.Array.Mem</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/QSort.html">Init.Data.Array.QSort</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array/Subarray.html">Init.Data.Array.Subarray</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/ByteArray.html">
<summary>Init.Data.ByteArray</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/ByteArray/Basic.html">Init.Data.ByteArray.Basic</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Char.html">
<summary>Init.Data.Char</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Char/Basic.html">Init.Data.Char.Basic</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Fin.html">
<summary>Init.Data.Fin</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Fin/Basic.html">Init.Data.Fin.Basic</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/FloatArray.html">
<summary>Init.Data.FloatArray</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/FloatArray/Basic.html">Init.Data.FloatArray.Basic</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Format.html">
<summary>Init.Data.Format</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Format/Basic.html">Init.Data.Format.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Format/Instances.html">Init.Data.Format.Instances</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Format/Macro.html">Init.Data.Format.Macro</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Format/Syntax.html">Init.Data.Format.Syntax</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Int.html">
<summary>Init.Data.Int</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Int/Basic.html">Init.Data.Int.Basic</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/List.html">
<summary>Init.Data.List</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/List/Basic.html">Init.Data.List.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/List/BasicAux.html">Init.Data.List.BasicAux</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/List/Control.html">Init.Data.List.Control</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Nat.html">
<summary>Init.Data.Nat</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Basic.html">Init.Data.Nat.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Bitwise.html">Init.Data.Nat.Bitwise</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Control.html">Init.Data.Nat.Control</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Div.html">Init.Data.Nat.Div</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Gcd.html">Init.Data.Nat.Gcd</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Linear.html">Init.Data.Nat.Linear</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/Log2.html">Init.Data.Nat.Log2</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat/SOM.html">Init.Data.Nat.SOM</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/Option.html">
<summary>Init.Data.Option</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Option/Basic.html">Init.Data.Option.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Option/BasicAux.html">Init.Data.Option.BasicAux</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Option/Instances.html">Init.Data.Option.Instances</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/String.html">
<summary>Init.Data.String</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/String/Basic.html">Init.Data.String.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/String/Extra.html">Init.Data.String.Extra</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/Data/ToString.html">
<summary>Init.Data.ToString</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/ToString/Basic.html">Init.Data.ToString.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/ToString/Macro.html">Init.Data.ToString.Macro</a>
</div>
</details>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/AC.html">Init.Data.AC</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Array.html">Init.Data.Array</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Basic.html">Init.Data.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/ByteArray.html">Init.Data.ByteArray</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Char.html">Init.Data.Char</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Fin.html">Init.Data.Fin</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Float.html">Init.Data.Float</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/FloatArray.html">Init.Data.FloatArray</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Format.html">Init.Data.Format</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Hashable.html">Init.Data.Hashable</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Int.html">Init.Data.Int</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/List.html">Init.Data.List</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Nat.html">Init.Data.Nat</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/OfScientific.html">Init.Data.OfScientific</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Option.html">Init.Data.Option</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Ord.html">Init.Data.Ord</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Prod.html">Init.Data.Prod</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Random.html">Init.Data.Random</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Range.html">Init.Data.Range</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Repr.html">Init.Data.Repr</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/Stream.html">Init.Data.Stream</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/String.html">Init.Data.String</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/ToString.html">Init.Data.ToString</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data/UInt.html">Init.Data.UInt</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Init/System.html">
<summary>Init.System</summary>
<div class="nav_link">
<a href="/Socket.lean/Init/System/FilePath.html">Init.System.FilePath</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/System/IO.html">Init.System.IO</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/System/IOError.html">Init.System.IOError</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/System/Platform.html">Init.System.Platform</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/System/ST.html">Init.System.ST</a>
</div>
</details>
<div class="nav_link">
<a href="/Socket.lean/Init/Classical.html">Init.Classical</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Coe.html">Init.Coe</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Control.html">Init.Control</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Conv.html">Init.Conv</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Core.html">Init.Core</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Data.html">Init.Data</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Fix.html">Init.Fix</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Hints.html">Init.Hints</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Meta.html">Init.Meta</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Notation.html">Init.Notation</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/NotationExtra.html">Init.NotationExtra</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Prelude.html">Init.Prelude</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/SimpLemmas.html">Init.SimpLemmas</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/SizeOf.html">Init.SizeOf</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/SizeOfLemmas.html">Init.SizeOfLemmas</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/System.html">Init.System</a>
</div>
<div class="nav_link" visible="">
<a href="/Socket.lean/Init/Tactics.html">Init.Tactics</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/Util.html">Init.Util</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/WF.html">Init.WF</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Init/WFTactics.html">Init.WFTactics</a>
</div>
</details>
<details class="nav_sect" data-path="/Socket.lean/Socket.html">
<summary>Socket</summary>
<div class="nav_link">
<a href="/Socket.lean/Socket/Basic.html">Socket.Basic</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Socket/Init.html">Socket.Init</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Socket/SockAddr.html">Socket.SockAddr</a>
</div>
<div class="nav_link">
<a href="/Socket.lean/Socket/Socket.html">Socket.Socket</a>
</div>
</details>
</div>
</nav>
<script>
siteRoot = "/Socket.lean/";
      </script>
<script src="/Socket.lean/nav.js">
</script>
<script src="/Socket.lean/search.js">
</script>
<script src="/Socket.lean/mathjax-config.js">
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6">
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</body>
</html>