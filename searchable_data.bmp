[{"name":"Socket.Socket.Nonempty","description":"Use `NonemptyType` to implement `Inhabited` for `Socket`.\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.Socket","description":"Opaque reference to underlying platform specific socket.\n\n  To create a `Socket`, refer to [`Socket.mk`](##Socket.Socket.mk). Then you\n  can manipulate the `Socket` using common socket functions like\n  [`Socket.bind`](##Socket.Socket.bind),[`Socket.connect`](##Socket.Socket.connect),\n  etc. For all functions available, refer to the [`Socket` module](Socket/Socket.html).\n\n  *NOTE*: `NonemptyType` is used to implement `Inhabited` for `Socket`. [detailed explanation](#explanation-usage-of-nonemptytype)\n\n  ```lean\n  import Socket\n  open Socket\n\n  def main : IO Unit := do\n    let s ‚Üê Socket.mk\n    -- some socket operations\n    s.close\n  ```\n"},{"name":"Socket.instNonemptySocket","description":"Use `NonemptyType` to implement `Inhabited` for `Socket`.\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.SockAddr.Nonempty","description":"Use `NonemptyType` to implement `Inhabited` for `SockAddr`.\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.SockAddr","description":"Opaque reference to underlying socket address.\n\n  *NOTE*: Different from the C `sockaddr`, `SockAddr` also includes length.\n"},{"name":"Socket.instNonemptySockAddr","description":"Use `NonemptyType` to implement `Inhabited` for `SockAddr`\n  [detailed explanation](#explanation-usage-of-nonemptytype)\n"},{"name":"Socket.AddressFamily","description":"Enumeration of supported address families,\n  which is used in [`Socket.mk`](/find/Socket.Socket.mk).\n"},{"name":"Socket.instInhabitedAddressFamily","description":""},{"name":"Socket.instToStringAddressFamily","description":"Convert `AddressFamily` to `String`. "},{"name":"Socket.SockType","description":"Enumeration of supported socket types,\n  which is used in [`Socket.mk`](/find/Socket.Socket.mk).\n"},{"name":"Socket.instInhabitedSockType","description":""},{"name":"Socket.instToStringSockType","description":"Convert `SockType` to `String`. "},{"name":"Socket.ShutdownHow","description":"Enumeration of how is socket shutdown,\n  which is used in [`Socket.shutdown`](##Socket.Socket.shutdown).\n"},{"name":"Socket.instInhabitedShutdownHow","description":""},{"name":"Socket.hostname","description":"Get hostname of current machine. "},{"name":"Option.get!","description":""},{"name":"IO.Error","description":""},{"name":"IO.instInhabitedError","description":""},{"name":"IO.userError","description":""},{"name":"instCoeStringError","description":""},{"name":"IO.Error.mkAlreadyExistsFile","description":""},{"name":"IO.Error.mkEofError","description":""},{"name":"IO.Error.mkInappropriateTypeFile","description":""},{"name":"IO.Error.mkInterrupted","description":""},{"name":"IO.Error.mkInvalidArgumentFile","description":""},{"name":"IO.Error.mkNoFileOrDirectory","description":""},{"name":"IO.Error.mkNoSuchThingFile","description":""},{"name":"IO.Error.mkPermissionDeniedFile","description":""},{"name":"IO.Error.mkResourceExhaustedFile","description":""},{"name":"IO.Error.mkUnsupportedOperation","description":""},{"name":"IO.Error.mkResourceExhausted","description":""},{"name":"IO.Error.mkAlreadyExists","description":""},{"name":"IO.Error.mkInappropriateType","description":""},{"name":"IO.Error.mkNoSuchThing","description":""},{"name":"IO.Error.mkResourceVanished","description":""},{"name":"IO.Error.mkResourceBusy","description":""},{"name":"IO.Error.mkInvalidArgument","description":""},{"name":"IO.Error.mkOtherError","description":""},{"name":"IO.Error.mkPermissionDenied","description":""},{"name":"IO.Error.mkHardwareFault","description":""},{"name":"IO.Error.mkUnsatisfiedConstraints","description":""},{"name":"IO.Error.mkIllegalOperation","description":""},{"name":"IO.Error.mkProtocolError","description":""},{"name":"IO.Error.mkTimeExpired","description":""},{"name":"IO.Error.fopenErrorToString","description":""},{"name":"IO.Error.otherErrorToString","description":""},{"name":"IO.Error.toString","description":""},{"name":"IO.Error.instToStringError","description":""},{"name":"Fin.coeToNat","description":""},{"name":"Fin.elim0","description":""},{"name":"Fin.succ","description":""},{"name":"Fin.ofNat","description":""},{"name":"Fin.ofNat'","description":""},{"name":"Fin.add","description":""},{"name":"Fin.mul","description":""},{"name":"Fin.sub","description":""},{"name":"Fin.mod","description":""},{"name":"Fin.div","description":""},{"name":"Fin.modn","description":""},{"name":"Fin.land","description":""},{"name":"Fin.lor","description":""},{"name":"Fin.xor","description":""},{"name":"Fin.shiftLeft","description":""},{"name":"Fin.shiftRight","description":""},{"name":"Fin.instAddFin","description":""},{"name":"Fin.instSubFin","description":""},{"name":"Fin.instMulFin","description":""},{"name":"Fin.instModFin","description":""},{"name":"Fin.instDivFin","description":""},{"name":"Fin.instAndOpFin","description":""},{"name":"Fin.instOrOpFin","description":""},{"name":"Fin.instXorFin","description":""},{"name":"Fin.instShiftLeftFin","description":""},{"name":"Fin.instShiftRightFin","description":""},{"name":"Fin.instHModFinNat","description":""},{"name":"Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat","description":""},{"name":"Fin.instInhabitedFinHAddNatInstHAddInstAddNatOfNat","description":""},{"name":"Fin.val_ne_of_ne","description":""},{"name":"Fin.modn_lt","description":""},{"name":"Socket.SockAddr.mk","description":"Create a [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.SockAddr.family","description":"Get family of the [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.SockAddr.port","description":"Get family of the [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.SockAddr.host","description":"Get family of the [`SockAddr`](##Socket.SockAddr). "},{"name":"Socket.instToStringSockAddr","description":"Convert [`SockAddr`](##Socket.SockAddr) to `String`. "},{"name":"dbgTrace","description":""},{"name":"dbgTraceVal","description":""},{"name":"dbgTraceIfShared","description":""},{"name":"dbgSleep","description":""},{"name":"panicWithPos","description":""},{"name":"panicWithPosWithDecl","description":""},{"name":"ptrAddrUnsafe","description":""},{"name":"withPtrAddrUnsafe","description":""},{"name":"withPtrEqUnsafe","description":""},{"name":"withPtrEq","description":""},{"name":"withPtrEqDecEq","description":"`withPtrEq` for `DecidableEq` "},{"name":"withPtrAddr","description":""},{"name":"OfScientific","description":""},{"name":"Float.ofBinaryScientific","description":"Computes `m * 2^e`. "},{"name":"instOfScientificFloat","description":""},{"name":"Float.ofNat","description":""},{"name":"Float.ofInt","description":""},{"name":"instOfNatFloat","description":""},{"name":"Nat.toFloat","description":""},{"name":"StateRefT'","description":""},{"name":"StateRefT'.run","description":""},{"name":"StateRefT'.run'","description":""},{"name":"StateRefT'.lift","description":""},{"name":"StateRefT'.instMonadStateRefT'","description":""},{"name":"StateRefT'.instMonadLiftStateRefT'","description":""},{"name":"StateRefT'.instMonadFunctorStateRefT'","description":""},{"name":"StateRefT'.instAlternativeStateRefT'","description":""},{"name":"StateRefT'.get","description":""},{"name":"StateRefT'.set","description":""},{"name":"StateRefT'.modifyGet","description":""},{"name":"StateRefT'.instMonadStateOfStateRefT'","description":""},{"name":"StateRefT'.instMonadExceptOfStateRefT'","description":""},{"name":"instMonadControlStateRefT'","description":""},{"name":"instMonadFinallyStateRefT'","description":""},{"name":"Except.pure","description":""},{"name":"Except.map","description":""},{"name":"Except.map_id","description":""},{"name":"Except.mapError","description":""},{"name":"Except.bind","description":""},{"name":"Except.toBool","description":""},{"name":"Except.toOption","description":""},{"name":"Except.tryCatch","description":""},{"name":"Except.orElseLazy","description":""},{"name":"Except.instMonadExcept","description":""},{"name":"ExceptT","description":""},{"name":"ExceptT.mk","description":""},{"name":"ExceptT.run","description":""},{"name":"ExceptT.pure","description":""},{"name":"ExceptT.bindCont","description":""},{"name":"ExceptT.bind","description":""},{"name":"ExceptT.map","description":""},{"name":"ExceptT.lift","description":""},{"name":"ExceptT.instMonadLiftExceptExceptT","description":""},{"name":"ExceptT.instMonadLiftExceptT","description":""},{"name":"ExceptT.tryCatch","description":""},{"name":"ExceptT.instMonadFunctorExceptT","description":""},{"name":"ExceptT.instMonadExceptT","description":""},{"name":"ExceptT.adapt","description":""},{"name":"instMonadExceptOfExceptT","description":""},{"name":"instMonadExceptOfExceptT_1","description":""},{"name":"instInhabitedExceptT","description":""},{"name":"instMonadExceptOfExcept","description":""},{"name":"MonadExcept.orelse'","description":"Alternative orelse operator that allows to select which exception should be used.\n    The default is to use the first exception since the standard `orelse` uses the second. "},{"name":"observing","description":""},{"name":"liftExcept","description":""},{"name":"instMonadControlExceptT","description":""},{"name":"MonadFinally","description":""},{"name":"tryFinally","description":"Execute `x` and then execute `finalizer` even if `x` threw an exception "},{"name":"Id.finally","description":""},{"name":"ExceptT.finally","description":""},{"name":"Array.mkArray","description":""},{"name":"Array.size_mkArray","description":""},{"name":"Array.instEmptyCollectionArray","description":""},{"name":"Array.instInhabitedArray","description":""},{"name":"Array.isEmpty","description":""},{"name":"Array.singleton","description":""},{"name":"Array.uget","description":""},{"name":"Array.back","description":""},{"name":"Array.get?","description":""},{"name":"Array.back?","description":""},{"name":"Array.getLit","description":""},{"name":"Array.size_set","description":""},{"name":"Array.size_push","description":""},{"name":"Array.uset","description":""},{"name":"Array.swap","description":""},{"name":"Array.swap!","description":""},{"name":"Array.swapAt","description":""},{"name":"Array.swapAt!","description":""},{"name":"Array.pop","description":""},{"name":"Array.shrink","description":""},{"name":"Array.shrink.loop","description":""},{"name":"Array.modifyMUnsafe","description":""},{"name":"Array.modifyM","description":""},{"name":"Array.modify","description":""},{"name":"Array.modifyOp","description":""},{"name":"Array.forInUnsafe","description":""},{"name":"Array.forInUnsafe.loop","description":""},{"name":"Array.forIn","description":""},{"name":"Array.forIn.loop","description":""},{"name":"Array.instForInArray","description":""},{"name":"Array.foldlMUnsafe","description":""},{"name":"Array.foldlMUnsafe.fold","description":""},{"name":"Array.foldlM","description":""},{"name":"Array.foldlM.loop","description":""},{"name":"Array.foldrMUnsafe","description":""},{"name":"Array.foldrMUnsafe.fold","description":""},{"name":"Array.foldrM","description":""},{"name":"Array.foldrM.fold","description":""},{"name":"Array.mapMUnsafe","description":""},{"name":"Array.mapMUnsafe.map","description":""},{"name":"Array.mapM","description":""},{"name":"Array.mapIdxM","description":""},{"name":"Array.mapIdxM.map","description":""},{"name":"Array.findSomeM?","description":""},{"name":"Array.findM?","description":""},{"name":"Array.findIdxM?","description":""},{"name":"Array.anyMUnsafe","description":""},{"name":"Array.anyMUnsafe.any","description":""},{"name":"Array.anyM","description":""},{"name":"Array.anyM.loop","description":""},{"name":"Array.allM","description":""},{"name":"Array.findSomeRevM?","description":""},{"name":"Array.findSomeRevM?.find","description":""},{"name":"Array.findRevM?","description":""},{"name":"Array.forM","description":""},{"name":"Array.forRevM","description":""},{"name":"Array.foldl","description":""},{"name":"Array.foldr","description":""},{"name":"Array.map","description":""},{"name":"Array.mapIdx","description":""},{"name":"Array.find?","description":""},{"name":"Array.findSome?","description":""},{"name":"Array.findSome!","description":""},{"name":"Array.findSomeRev?","description":""},{"name":"Array.findRev?","description":""},{"name":"Array.findIdx?","description":""},{"name":"Array.findIdx?.loop","description":""},{"name":"Array.getIdx?","description":""},{"name":"Array.any","description":""},{"name":"Array.all","description":""},{"name":"Array.contains","description":""},{"name":"Array.elem","description":""},{"name":"Array.reverse","description":""},{"name":"Array.reverse.rev","description":""},{"name":"Array.getEvenElems","description":""},{"name":"Array.toList","description":""},{"name":"Array.instReprArray","description":""},{"name":"Array.instToStringArray","description":""},{"name":"Array.append","description":""},{"name":"Array.instAppendArray","description":""},{"name":"Array.appendList","description":""},{"name":"Array.instHAppendArrayList","description":""},{"name":"Array.concatMapM","description":""},{"name":"Array.concatMap","description":""},{"name":"¬´term#[_,]¬ª","description":""},{"name":"Array.isEqvAux","description":""},{"name":"Array.isEqv","description":""},{"name":"Array.instBEqArray","description":""},{"name":"Array.filter","description":""},{"name":"Array.filterM","description":""},{"name":"Array.filterMapM","description":""},{"name":"Array.filterMap","description":""},{"name":"Array.getMax?","description":""},{"name":"Array.partition","description":""},{"name":"Array.ext","description":""},{"name":"Array.ext.extAux","description":""},{"name":"Array.extLit","description":""},{"name":"Array.indexOfAux","description":""},{"name":"Array.indexOf?","description":""},{"name":"Array.size_swap","description":""},{"name":"Array.size_pop","description":""},{"name":"Array.popWhile","description":""},{"name":"Array.takeWhile","description":""},{"name":"Array.takeWhile.go","description":""},{"name":"Array.eraseIdxAux","description":""},{"name":"Array.feraseIdx","description":""},{"name":"Array.eraseIdx","description":""},{"name":"Array.eraseIdxSzAux","description":""},{"name":"Array.eraseIdx'","description":""},{"name":"Array.erase","description":""},{"name":"Array.insertAtAux","description":""},{"name":"Array.insertAt","description":"Insert element `a` at position `i`.\n  Pre: `i < as.size` "},{"name":"Array.toListLitAux","description":""},{"name":"Array.toArrayLit","description":""},{"name":"Array.toArrayLit_eq","description":""},{"name":"Array.isPrefixOfAux","description":""},{"name":"Array.isPrefixOf","description":""},{"name":"Array.allDiff","description":""},{"name":"Array.zipWithAux","description":""},{"name":"Array.zipWith","description":""},{"name":"Array.zip","description":""},{"name":"Array.unzip","description":""},{"name":"Array.split","description":""},{"name":"Array.eq_of_isEqvAux","description":""},{"name":"Array.eq_of_isEqv","description":""},{"name":"Array.isEqvAux_self","description":""},{"name":"Array.isEqv_self","description":""},{"name":"Array.instDecidableEqArray","description":""},{"name":"Lean.Parser.Tactic.withAnnotateState","description":"`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with the initial and final state of running tactic `t`. "},{"name":"Lean.Parser.Tactic.intro","description":"Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n"},{"name":"Lean.Parser.Tactic.intros","description":"`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous) hypotheses until goal is not of a function type. "},{"name":"Lean.Parser.Tactic.rename","description":"`rename t => x` renames the most recent hypothesis whose type matches `t` (which may contain placeholders) to `x`,\nor fails if no such hypothesis could be found. "},{"name":"Lean.Parser.Tactic.revert","description":"`revert x...` is the inverse of `intro x...`: it moves the given hypotheses into the main goal's target type. "},{"name":"Lean.Parser.Tactic.clear","description":"`clear x...` removes the given hypotheses, or fails if there are remaining references to a hypothesis. "},{"name":"Lean.Parser.Tactic.subst","description":"`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. "},{"name":"Lean.Parser.Tactic.substVars","description":"Apply `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n"},{"name":"Lean.Parser.Tactic.assumption","description":"`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‚Äπt‚Ä∫` term notation, which is a shorthand for `show t by assumption`. "},{"name":"Lean.Parser.Tactic.contradiction","description":"`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n- Inductive type/family with no applicable constructors\n```lean\nexample (h : False) : p := by contradiction\n```\n- Injectivity of constructors\n```lean\nexample (h : none = some true) : p := by contradiction  --\n```\n- Decidable false proposition\n```lean\nexample (h : 2 + 2 = 3) : p := by contradiction\n```\n- Contradictory hypotheses\n```lean\nexample (h : p) (h' : ¬¨ p) : q := by contradiction\n```\n- Other simple contradictions such as\n```lean\nexample (x : Nat) (h : x ‚â† x) : p := by contradiction\n```\n"},{"name":"Lean.Parser.Tactic.apply","description":"`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n"},{"name":"Lean.Parser.Tactic.exact","description":"`exact e` closes the main goal if its target type matches that of `e`.\n"},{"name":"Lean.Parser.Tactic.refine","description":"`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`) holes in `e` that are not solved\nby unification with the main goal's target type are converted into new goals, using the hole's name, if any, as the goal case name.\n"},{"name":"Lean.Parser.Tactic.refine'","description":"`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`) and implicit parameters are also converted into new goals. "},{"name":"Lean.Parser.Tactic.constructor","description":"If the main goal's target type is an inductive type, `constructor` solves it with the first matching constructor, or else fails. "},{"name":"Lean.Parser.Tactic.case","description":"`case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`, or else fails.\n`case tag x‚ÇÅ ... x‚Çô => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"name":"Lean.Parser.Tactic.case'","description":"`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal has been solved after applying `tac`, nor\nadmits the goal if `tac` failed. Recall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n"},{"name":"Lean.Parser.Tactic.¬´tacticNext___=>_¬ª","description":"`next => tac` focuses on the next goal solves it using `tac`, or else fails.\n`next x‚ÇÅ ... x‚Çô => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"name":"Lean.Parser.Tactic.allGoals","description":"`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. "},{"name":"Lean.Parser.Tactic.anyGoals","description":"`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at least one application succeeds.  "},{"name":"Lean.Parser.Tactic.focus","description":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `¬∑ tac`, which enforces that the goal is closed by `tac`, should be preferred. "},{"name":"Lean.Parser.Tactic.skip","description":"`skip` does nothing. "},{"name":"Lean.Parser.Tactic.done","description":"`done` succeeds iff there are no remaining goals. "},{"name":"Lean.Parser.Tactic.traceState","description":"`trace_state` displays the current state in the info view. "},{"name":"Lean.Parser.Tactic.traceMessage","description":"`trace msg` displays `msg` in the info view. "},{"name":"Lean.Parser.Tactic.failIfSuccess","description":"`fail_if_success t` fails if the tactic `t` succeeds. "},{"name":"Lean.Parser.Tactic.paren","description":""},{"name":"Lean.Parser.Tactic.withReducible","description":""},{"name":"Lean.Parser.Tactic.withReducibleAndInstances","description":""},{"name":"Lean.Parser.Tactic.withUnfoldingAll","description":""},{"name":"Lean.Parser.Tactic.first","description":"`first | tac | ...` runs each `tac` until one succeeds, or else fails. "},{"name":"Lean.Parser.Tactic.rotateLeft","description":""},{"name":"Lean.Parser.Tactic.rotateRight","description":""},{"name":"Lean.Parser.Tactic.tacticTry_","description":"`try tac` runs `tac` and succeeds even if `tac` failed. "},{"name":"Lean.Parser.Tactic.¬´tactic_<;>_¬ª","description":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals produced by `tac'`. "},{"name":"Lean.Parser.Tactic.refl","description":"`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. "},{"name":"Lean.Parser.Tactic.tacticRfl","description":"`rfl` tries to close the current goal using reflexivity.\nThis is supposed to be an extensible tactic and users can add their own support\nfor new reflexive relations.\n"},{"name":"Lean.Parser.Tactic.tacticRfl'","description":"`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\n  theorems included (relevant for declarations defined by well-founded recursion). "},{"name":"Lean.Parser.Tactic.ac_refl","description":""},{"name":"Lean.Parser.Tactic.tacticAdmit","description":"`admit` is a shorthand for `exact sorry`. "},{"name":"Lean.Parser.Tactic.tacticSorry","description":"The `sorry` tactic is a shorthand for `exact sorry`. "},{"name":"Lean.Parser.Tactic.tacticInfer_instance","description":"`infer_instance` is an abbreviation for `exact inferInstance` "},{"name":"Lean.Parser.Tactic.config","description":"Optional configuration option for tactics "},{"name":"Lean.Parser.Tactic.locationWildcard","description":""},{"name":"Lean.Parser.Tactic.locationHyp","description":""},{"name":"Lean.Parser.Tactic.location","description":""},{"name":"Lean.Parser.Tactic.change","description":""},{"name":"Lean.Parser.Tactic.changeWith","description":""},{"name":"Lean.Parser.Tactic.rwRule","description":""},{"name":"Lean.Parser.Tactic.rwRuleSeq","description":""},{"name":"Lean.Parser.Tactic.rewriteSeq","description":"`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`‚Üê` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used. This provides a convenient way to unfold `e`.\n- `rewrite [e‚ÇÅ, ..., e‚Çô]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a list of hypotheses in the local context. In the latter case, a turnstile `‚ä¢` or `|-` can also be used, to signify the target of the goal.\n"},{"name":"Lean.Parser.Tactic.rwSeq","description":"`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n"},{"name":"Lean.Parser.Tactic.rwWithRfl","description":""},{"name":"Lean.Parser.Tactic.expandRwSeq","description":""},{"name":"Lean.Parser.Tactic.injection","description":"The `injection` tactic is based on the fact that constructors of inductive data types are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t‚ÇÅ)` and `(c t‚ÇÇ)` are two terms that are equal then  `t‚ÇÅ` and `t‚ÇÇ` are equal too.\nIf `q` is a proof of a statement of conclusion `t‚ÇÅ = t‚ÇÇ`, then injection applies injectivity to derive the equality of all arguments of `t‚ÇÅ` and `t‚ÇÇ`\nplaced in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t‚ÇÅ` and `t‚ÇÇ`\nshould be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal.\nThe tactic `injection h with h‚ÇÅ h‚ÇÇ` uses the names `h‚ÇÅ` and `h‚ÇÇ` to name the new hypotheses.\n"},{"name":"Lean.Parser.Tactic.injections","description":""},{"name":"Lean.Parser.Tactic.discharger","description":""},{"name":"Lean.Parser.Tactic.simpPre","description":""},{"name":"Lean.Parser.Tactic.simpPost","description":""},{"name":"Lean.Parser.Tactic.simpLemma","description":""},{"name":"Lean.Parser.Tactic.simpErase","description":""},{"name":"Lean.Parser.Tactic.simpStar","description":""},{"name":"Lean.Parser.Tactic.simp","description":"The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `h·µ¢`'s, where the `h·µ¢`'s are expressions. If an `h·µ¢` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.\n- `simp only [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]` is like `simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]` but does not use `[simp]` lemmas\n- `simp [-id‚ÇÅ, ..., -id‚Çô]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `id·µ¢`.\n- `simp at h‚ÇÅ h‚ÇÇ ... h‚Çô` simplifies the hypotheses `h‚ÇÅ : T‚ÇÅ` ... `h‚Çô : T‚Çô`. If the target or another hypothesis depends on `h·µ¢`, a new simplified hypothesis `h·µ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the other hypotheses.\n"},{"name":"Lean.Parser.Tactic.simpAll","description":"`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target are simplified\nmultiple times until no simplication is applicable.\nOnly non-dependent propositional hypotheses are considered.\n"},{"name":"Lean.Parser.Tactic.dsimp","description":"The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only applies theorems that hold by\nreflexivity. Thus, the result is guaranteed to be definitionally equal to the input.\n"},{"name":"Lean.Parser.Tactic.delta","description":"`delta id` delta-expands the definition `id`.\n  This is a low-level tactic, it will expose how recursive definitions have been compiled by Lean. "},{"name":"Lean.Parser.Tactic.unfold","description":"`unfold id,+` unfolds definition `id`. For non-recursive definitions, this tactic is identical to `delta`.\n  For recursive definitions, it hides the encoding tricks used by the Lean frontend to convince the\n  kernel that the definition terminates. "},{"name":"Lean.Parser.Tactic.tacticRefine_lift_","description":""},{"name":"Lean.Parser.Tactic.tacticHave_","description":"`have h : t := e` adds the hypothesis `h : t` to the current goal if `e` a term of type `t`. If `t` is omitted, it will be inferred.\nIf `h` is omitted, the name `this` is used.\nThe variant `have pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ‚àß q ‚àß r`, `have ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h` produces the hypotheses `h‚ÇÅ : p`, `h‚ÇÇ : q`, and `h‚ÇÉ : r`.\n"},{"name":"Lean.Parser.Tactic.¬´tacticHave__:=_¬ª","description":"`have h := e` adds the hypothesis `h : t` if `e : t`.\n"},{"name":"Lean.Parser.Tactic.tacticSuffices_","description":"Given a main goal `ctx |- t`, `suffices h : t' from e` replaces the main goal with `ctx |- t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n "},{"name":"Lean.Parser.Tactic.tacticLet_","description":"`let h : t := e` adds the hypothesis `h : t := e` to the current goal if `e` a term of type `t`.\nIf `t` is omitted, it will be inferred.\nThe variant `let pattern := e` is equivalent to `match e with | pattern => _`, and it is convenient for types that have only applicable constructor.\nExample: given `h : p ‚àß q ‚àß r`, `let ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h` produces the hypotheses `h‚ÇÅ : p`, `h‚ÇÇ : q`, and `h‚ÇÉ : r`.\n"},{"name":"Lean.Parser.Tactic.tacticShow_","description":"`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\n performs the unification, and replaces the target with the unified version of `t`.\n"},{"name":"Lean.Parser.Tactic.letrec","description":""},{"name":"Lean.Parser.Tactic.tacticRefine_lift'_","description":""},{"name":"Lean.Parser.Tactic.tacticHave'_","description":""},{"name":"Lean.Parser.Tactic.¬´tacticHave'__:=_¬ª","description":""},{"name":"Lean.Parser.Tactic.tacticLet'_","description":""},{"name":"Lean.Parser.Tactic.inductionAltLHS","description":""},{"name":"Lean.Parser.Tactic.inductionAlt","description":""},{"name":"Lean.Parser.Tactic.inductionAlts","description":""},{"name":"Lean.Parser.Tactic.induction","description":"Assuming `x` is a variable in the local context with an inductive type, `induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `induction n` produces one goal\nwith hypothesis `h : P 0` and target `Q 0`, and one goal with hypotheses `h : P (Nat.succ a)` and `ih‚ÇÅ : P a ‚Üí Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih‚ÇÅ` are chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used. Here `r` should be a theorem whose result type must be of the form `C t`, where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z‚ÇÅ ... z‚Çô`, where `z‚ÇÅ ... z‚Çô` are variables in the local context, generalizes over `z‚ÇÅ ... z‚Çô` before applying the induction but then introduces them in each goal. In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac‚ÇÅ | succ x' ih => tac‚ÇÇ` uses tactic `tac‚ÇÅ` for the `zero` case, and `tac‚ÇÇ` for the `succ` case.\n"},{"name":"Lean.Parser.Tactic.generalizeArg","description":""},{"name":"Lean.Parser.Tactic.generalize","description":"`generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal with a fresh hypothesis `x`s.\nIf `h` is given, `h : e = x` is introduced as well. "},{"name":"Lean.Parser.Tactic.casesTarget","description":""},{"name":"Lean.Parser.Tactic.cases","description":"Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal,\nproducing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well. `cases` detects unreachable cases and closes them automatically.\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`. Here the name `a` is chosen automatically and are not accessible. You can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.\n- Given `as : List Œ±`, `cases as with | nil => tac‚ÇÅ | cons a as' => tac‚ÇÇ`, uses tactic `tac‚ÇÅ` for the `nil` case, and `tac‚ÇÇ` for the `cons` case, and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.\n"},{"name":"Lean.Parser.Tactic.renameI","description":"`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. "},{"name":"Lean.Parser.Tactic.tacticRepeat_","description":"`repeat tac` applies `tac` to main goal. If the application succeeds,\nthe tactic is applied recursively to the generated subgoals until it eventually fails.\n"},{"name":"Lean.Parser.Tactic.tacticTrivial","description":"`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...) to close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n"},{"name":"Lean.Parser.Tactic.split","description":"The `split` tactic is useful for breaking nested if-then-else and match expressions in cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals\n"},{"name":"Lean.Parser.Tactic.dbgTrace","description":""},{"name":"Lean.Parser.Tactic.tacticStop_","description":"`stop` is a helper tactic for \"discarding\" the rest of a proof. It is useful when working on the middle of a complex proofs,\n    and less messy than commenting the remainder of the proof. "},{"name":"Lean.Parser.Tactic.specialize","description":"The tactic `specialize h a‚ÇÅ ... a‚Çô` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or non-dependent implications,\nare instantiated by concrete terms coming either from arguments `a‚ÇÅ` ... `a‚Çô`.\nThe tactic adds a new hypothesis with the same name `h := h a‚ÇÅ ... a‚Çô` and tries to clear the previous one.\n"},{"name":"Lean.Parser.Tactic.tacticUnhygienic_","description":""},{"name":"Lean.Parser.Tactic.fail","description":"`fail msg` is a tactic that always fail and produces an error using the given message. "},{"name":"Lean.Parser.Tactic.checkpoint","description":""},{"name":"Lean.Parser.Tactic.save","description":""},{"name":"Lean.Parser.Tactic.sleep","description":"The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing. It is used for debugging purposes only. "},{"name":"Lean.Parser.Tactic.¬´tacticExists_,,¬ª","description":"`exists e‚ÇÅ, e‚ÇÇ, ...` is shorthand for `refine ‚ü®e‚ÇÅ, e‚ÇÇ, ...‚ü©; try trivial`. It is useful for existential goals. "},{"name":"Lean.Parser.Attr.simp","description":""},{"name":"¬´term‚Äπ_‚Ä∫¬ª","description":"`‚Äπt‚Ä∫` resolves to an (arbitrary) hypothesis of type `t`. It is useful for referring to hypotheses without accessible names.\n`t` may contain holes that are solved by unification with the expected type; in particular, `‚Äπ_‚Ä∫` is a shortcut for `by assumption`. "},{"name":"Socket.initSocket","description":"The initialization function. Users shouldn't call this. "},{"name":"Option.eq_of_eq_some","description":""},{"name":"Option.eq_none_of_isNone","description":""},{"name":"Array.insertionSort","description":""},{"name":"Array.insertionSort.traverse","description":""},{"name":"Array.insertionSort.swapLoop","description":""},{"name":"ExceptCpsT","description":""},{"name":"ExceptCpsT.run","description":""},{"name":"ExceptCpsT.runK","description":""},{"name":"ExceptCpsT.runCatch","description":""},{"name":"ExceptCpsT.instMonadExceptCpsT","description":""},{"name":"ExceptCpsT.instLawfulMonadExceptCpsTInstMonadExceptCpsT","description":""},{"name":"ExceptCpsT.instMonadExceptOfExceptCpsT","description":""},{"name":"ExceptCpsT.lift","description":""},{"name":"ExceptCpsT.instMonadLiftExceptCpsT","description":""},{"name":"ExceptCpsT.instInhabitedExceptCpsT","description":""},{"name":"ExceptCpsT.run_pure","description":""},{"name":"ExceptCpsT.run_lift","description":""},{"name":"ExceptCpsT.run_throw","description":""},{"name":"ExceptCpsT.run_bind_lift","description":""},{"name":"ExceptCpsT.run_bind_throw","description":""},{"name":"ExceptCpsT.runCatch_pure","description":""},{"name":"ExceptCpsT.runCatch_lift","description":""},{"name":"ExceptCpsT.runCatch_throw","description":""},{"name":"ExceptCpsT.runCatch_bind_lift","description":""},{"name":"ExceptCpsT.runCatch_bind_throw","description":""},{"name":"EST","description":""},{"name":"ST","description":""},{"name":"instMonadEST","description":""},{"name":"instMonadExceptOfEST","description":""},{"name":"instInhabitedEST","description":""},{"name":"instMonadST","description":""},{"name":"STWorld","description":""},{"name":"instSTWorld","description":""},{"name":"instSTWorldEST","description":""},{"name":"runEST","description":""},{"name":"runST","description":""},{"name":"instMonadLiftSTEST","description":""},{"name":"ST.RefPointed","description":""},{"name":"ST.Ref","description":""},{"name":"ST.instNonemptyRef","description":""},{"name":"ST.Prim.mkRef","description":""},{"name":"ST.Prim.Ref.get","description":""},{"name":"ST.Prim.Ref.set","description":""},{"name":"ST.Prim.Ref.swap","description":""},{"name":"ST.Prim.Ref.take","description":""},{"name":"ST.Prim.Ref.ptrEq","description":""},{"name":"ST.Prim.Ref.modifyUnsafe","description":""},{"name":"ST.Prim.Ref.modifyGetUnsafe","description":""},{"name":"ST.Prim.Ref.modify","description":""},{"name":"ST.Prim.Ref.modifyGet","description":""},{"name":"ST.mkRef","description":""},{"name":"ST.Ref.get","description":""},{"name":"ST.Ref.set","description":""},{"name":"ST.Ref.swap","description":""},{"name":"ST.Ref.take","description":""},{"name":"ST.Ref.ptrEq","description":""},{"name":"ST.Ref.modify","description":""},{"name":"ST.Ref.modifyGet","description":""},{"name":"Acc","description":""},{"name":"Acc.ndrec","description":""},{"name":"Acc.ndrecOn","description":""},{"name":"Acc.inv","description":""},{"name":"WellFounded","description":""},{"name":"WellFoundedRelation","description":""},{"name":"WellFounded.apply","description":""},{"name":"WellFounded.recursion","description":""},{"name":"WellFounded.induction","description":""},{"name":"WellFounded.fixF","description":""},{"name":"WellFounded.fixFEq","description":""},{"name":"WellFounded.fix","description":""},{"name":"WellFounded.fix_eq","description":""},{"name":"emptyWf","description":""},{"name":"Subrelation.accessible","description":""},{"name":"Subrelation.wf","description":""},{"name":"InvImage.accessible","description":""},{"name":"InvImage.wf","description":""},{"name":"invImage","description":""},{"name":"TC.accessible","description":""},{"name":"TC.wf","description":""},{"name":"Nat.lt_wfRel","description":""},{"name":"Nat.strongInductionOn","description":""},{"name":"Nat.caseStrongInductionOn","description":""},{"name":"Measure","description":""},{"name":"measure","description":""},{"name":"SizeOfRef","description":""},{"name":"sizeOfWFRel","description":""},{"name":"instWellFoundedRelation","description":""},{"name":"Prod.Lex","description":""},{"name":"Prod.Lex.right'","description":""},{"name":"Prod.RProd","description":""},{"name":"Prod.lexAccessible","description":""},{"name":"Prod.lex","description":""},{"name":"Prod.instWellFoundedRelationProd","description":""},{"name":"Prod.RProdSubLex","description":""},{"name":"Prod.rprod","description":""},{"name":"PSigma.Lex","description":""},{"name":"PSigma.lexAccessible","description":""},{"name":"PSigma.lex","description":""},{"name":"PSigma.instWellFoundedRelationPSigma","description":""},{"name":"PSigma.lexNdep","description":""},{"name":"PSigma.lexNdepWf","description":""},{"name":"PSigma.RevLex","description":""},{"name":"PSigma.revLexAccessible","description":""},{"name":"PSigma.revLex","description":""},{"name":"PSigma.SkipLeft","description":""},{"name":"PSigma.skipLeft","description":""},{"name":"PSigma.mkSkipLeft","description":""},{"name":"eq_self","description":""},{"name":"of_eq_true","description":""},{"name":"eq_true","description":""},{"name":"eq_false","description":""},{"name":"eq_false'","description":""},{"name":"eq_true_of_decide","description":""},{"name":"eq_false_of_decide","description":""},{"name":"implies_congr","description":""},{"name":"implies_congr_ctx","description":""},{"name":"implies_dep_congr_ctx","description":""},{"name":"forall_congr","description":""},{"name":"let_congr","description":""},{"name":"let_val_congr","description":""},{"name":"let_body_congr","description":""},{"name":"ite_congr","description":""},{"name":"Eq.mpr_prop","description":""},{"name":"Eq.mpr_not","description":""},{"name":"dite_congr","description":""},{"name":"ne_eq","description":""},{"name":"ite_true","description":""},{"name":"ite_false","description":""},{"name":"dite_true","description":""},{"name":"dite_false","description":""},{"name":"ite_self","description":""},{"name":"and_self","description":""},{"name":"and_true","description":""},{"name":"true_and","description":""},{"name":"and_false","description":""},{"name":"false_and","description":""},{"name":"or_self","description":""},{"name":"or_true","description":""},{"name":"true_or","description":""},{"name":"or_false","description":""},{"name":"false_or","description":""},{"name":"iff_self","description":""},{"name":"iff_true","description":""},{"name":"true_iff","description":""},{"name":"iff_false","description":""},{"name":"false_iff","description":""},{"name":"false_implies","description":""},{"name":"implies_true","description":""},{"name":"true_implies","description":""},{"name":"Bool.or_false","description":""},{"name":"Bool.or_true","description":""},{"name":"Bool.false_or","description":""},{"name":"Bool.true_or","description":""},{"name":"Bool.or_self","description":""},{"name":"Bool.or_eq_true","description":""},{"name":"Bool.and_false","description":""},{"name":"Bool.and_true","description":""},{"name":"Bool.false_and","description":""},{"name":"Bool.true_and","description":""},{"name":"Bool.and_self","description":""},{"name":"Bool.and_eq_true","description":""},{"name":"Bool.not_not","description":""},{"name":"Bool.not_true","description":""},{"name":"Bool.not_false","description":""},{"name":"Bool.not_beq_true","description":""},{"name":"Bool.not_beq_false","description":""},{"name":"Bool.beq_to_eq","description":""},{"name":"Bool.not_beq_to_not_eq","description":""},{"name":"Bool.not_eq_true","description":""},{"name":"Bool.not_eq_false","description":""},{"name":"decide_eq_true_eq","description":""},{"name":"decide_not","description":""},{"name":"not_decide_eq_true","description":""},{"name":"heq_eq_eq","description":""},{"name":"cond_true","description":""},{"name":"cond_false","description":""},{"name":"beq_self_eq_true","description":""},{"name":"beq_self_eq_true'","description":""},{"name":"Nat.le_zero_eq","description":""},{"name":"decide_False","description":""},{"name":"decide_True","description":""},{"name":"List.mapM","description":""},{"name":"List.mapA","description":""},{"name":"List.forM","description":""},{"name":"List.forA","description":""},{"name":"List.filterAuxM","description":""},{"name":"List.filterM","description":""},{"name":"List.filterRevM","description":""},{"name":"List.filterMapM","description":""},{"name":"List.filterMapM.loop","description":""},{"name":"List.foldlM","description":""},{"name":"List.foldrM","description":""},{"name":"List.firstM","description":""},{"name":"List.anyM","description":""},{"name":"List.allM","description":""},{"name":"List.findM?","description":""},{"name":"List.findSomeM?","description":""},{"name":"List.forIn","description":""},{"name":"List.forIn.loop","description":""},{"name":"List.instForInList","description":""},{"name":"List.forIn_nil","description":""},{"name":"List.forIn_cons","description":""},{"name":"List.forIn'","description":""},{"name":"List.forIn'.loop","description":""},{"name":"List.instForIn'ListInferInstanceMembershipInstMembershipList","description":""},{"name":"List.forIn'_eq_forIn","description":""},{"name":"List.instForMList","description":""},{"name":"List.forM_nil","description":""},{"name":"List.forM_cons","description":""},{"name":"System.FilePath","description":""},{"name":"System.instInhabitedFilePath","description":""},{"name":"System.instDecidableEqFilePath","description":""},{"name":"System.instHashableFilePath","description":""},{"name":"System.instReprFilePath","description":""},{"name":"System.instToStringFilePath","description":""},{"name":"System.FilePath.pathSeparator","description":"The character that separates directories. In the case where more than one character is possible, `pathSeparator` is the 'ideal' one. "},{"name":"System.FilePath.pathSeparators","description":"The list of all possible separators. "},{"name":"System.FilePath.extSeparator","description":"File extension character "},{"name":"System.FilePath.exeExtension","description":""},{"name":"System.FilePath.isCaseInsensitive","description":"Case-insensitive file system "},{"name":"System.FilePath.normalize","description":""},{"name":"System.FilePath.isAbsolute","description":""},{"name":"System.FilePath.isRelative","description":""},{"name":"System.FilePath.join","description":""},{"name":"System.FilePath.instDivFilePath","description":""},{"name":"System.FilePath.instHDivFilePathString","description":""},{"name":"System.FilePath.parent","description":""},{"name":"System.FilePath.fileName","description":""},{"name":"System.FilePath.fileStem","description":"Extracts the stem (non-extension) part of `p.fileName`. "},{"name":"System.FilePath.extension","description":""},{"name":"System.FilePath.withFileName","description":""},{"name":"System.FilePath.withExtension","description":""},{"name":"System.FilePath.components","description":""},{"name":"System.mkFilePath","description":""},{"name":"System.instCoeStringFilePath","description":""},{"name":"System.SearchPath","description":""},{"name":"System.SearchPath.separator","description":"The character that is used to separate the entries in the $PATH (or %PATH%) environment variable. "},{"name":"System.SearchPath.parse","description":""},{"name":"System.SearchPath.toString","description":""},{"name":"Functor.mapRev","description":""},{"name":"¬´term_<&>_¬ª","description":""},{"name":"Functor.discard","description":""},{"name":"Alternative","description":""},{"name":"instOrElse","description":""},{"name":"guard","description":""},{"name":"optional","description":""},{"name":"ToBool","description":""},{"name":"instToBoolBool","description":""},{"name":"bool","description":""},{"name":"orM","description":""},{"name":"¬´term_<||>_¬ª","description":""},{"name":"andM","description":""},{"name":"¬´term_<&&>_¬ª","description":""},{"name":"notM","description":""},{"name":"MonadControl","description":"MonadControl is a way of stating that the monad `m` can be 'run inside' the monad `n`.\n\nThis is the same as [`MonadBaseControl`](https://hackage.haskell.org/package/monad-control-1.0.3.1/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl) in Haskell.\nTo learn about `MonadControl`, see the comment above this docstring.\n\n"},{"name":"MonadControlT","description":"Transitive closure of MonadControl. "},{"name":"instMonadControlT","description":""},{"name":"instMonadControlT_1","description":""},{"name":"controlAt","description":""},{"name":"control","description":""},{"name":"ForM","description":""},{"name":"inline","description":""},{"name":"flip","description":""},{"name":"Function.const_apply","description":""},{"name":"Function.comp_apply","description":""},{"name":"Thunk","description":"Thunks are \"lazy\" values that are evaluated when first accessed using `Thunk.get/map/bind`.\n  The value is then stored and not recomputed for all further accesses. "},{"name":"Thunk.pure","description":"Store a value in a thunk. Note that the value has already been computed, so there is no laziness. "},{"name":"Thunk.get","description":""},{"name":"Thunk.map","description":""},{"name":"Thunk.bind","description":""},{"name":"Thunk.sizeOf_eq","description":""},{"name":"Iff","description":""},{"name":"¬´term_<->_¬ª","description":""},{"name":"¬´term_‚Üî_¬ª","description":""},{"name":"Sum","description":""},{"name":"¬´term_‚äï_¬ª","description":""},{"name":"PSum","description":""},{"name":"¬´term_‚äï'_¬ª","description":""},{"name":"Sigma","description":""},{"name":"PSigma","description":""},{"name":"Exists","description":""},{"name":"ForInStep","description":""},{"name":"ForIn","description":""},{"name":"ForIn'","description":""},{"name":"DoResultPRBC","description":""},{"name":"DoResultPR","description":""},{"name":"DoResultBC","description":""},{"name":"DoResultSBC","description":""},{"name":"HasEquiv","description":""},{"name":"¬´term_‚âà_¬ª","description":""},{"name":"EmptyCollection","description":""},{"name":"¬´term{}¬ª","description":""},{"name":"¬´term‚àÖ¬ª","description":""},{"name":"Task","description":""},{"name":"instInhabitedTask","description":""},{"name":"Task.Priority","description":"Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. "},{"name":"Task.Priority.default","description":""},{"name":"Task.Priority.max","description":""},{"name":"Task.Priority.dedicated","description":"Any priority higher than `Task.Priority.max` will result in the task being scheduled immediately on a dedicated thread.\n  This is particularly useful for long-running and/or I/O-bound tasks since Lean will by default allocate no more\n  non-dedicated workers than the number of cores to reduce context switches. "},{"name":"Task.spawn","description":""},{"name":"Task.map","description":""},{"name":"Task.bind","description":""},{"name":"NonScalar","description":""},{"name":"PNonScalar","description":""},{"name":"Nat.add_zero","description":""},{"name":"optParam_eq","description":""},{"name":"strictOr","description":""},{"name":"strictAnd","description":""},{"name":"bne","description":""},{"name":"¬´term_!=_¬ª","description":""},{"name":"LawfulBEq","description":""},{"name":"eq_of_beq","description":""},{"name":"instLawfulBEqBoolInstBEqInstDecidableEqBool","description":""},{"name":"instLawfulBEqCharInstBEqInstDecidableEqChar","description":""},{"name":"instLawfulBEqStringInstBEqInstDecidableEqString","description":""},{"name":"implies","description":""},{"name":"implies.trans","description":""},{"name":"trivial","description":""},{"name":"mt","description":""},{"name":"not_false","description":""},{"name":"not_not_intro","description":""},{"name":"proofIrrel","description":""},{"name":"id.def","description":""},{"name":"Eq.mp","description":""},{"name":"Eq.mpr","description":""},{"name":"Eq.substr","description":""},{"name":"cast_eq","description":""},{"name":"Ne","description":""},{"name":"¬´term_‚â†_¬ª","description":""},{"name":"Ne.intro","description":""},{"name":"Ne.elim","description":""},{"name":"Ne.irrefl","description":""},{"name":"Ne.symm","description":""},{"name":"false_of_ne","description":""},{"name":"ne_false_of_self","description":""},{"name":"ne_true_of_not","description":""},{"name":"true_ne_false","description":""},{"name":"Bool.of_not_eq_true","description":""},{"name":"Bool.of_not_eq_false","description":""},{"name":"ne_of_beq_false","description":""},{"name":"beq_false_of_ne","description":""},{"name":"HEq.ndrec","description":""},{"name":"HEq.ndrecOn","description":""},{"name":"HEq.elim","description":""},{"name":"HEq.subst","description":""},{"name":"HEq.symm","description":""},{"name":"heq_of_eq","description":""},{"name":"HEq.trans","description":""},{"name":"heq_of_heq_of_eq","description":""},{"name":"heq_of_eq_of_heq","description":""},{"name":"type_eq_of_heq","description":""},{"name":"eqRec_heq","description":""},{"name":"heq_of_eqRec_eq","description":""},{"name":"cast_heq","description":""},{"name":"iff_iff_implies_and_implies","description":""},{"name":"Iff.refl","description":""},{"name":"Iff.rfl","description":""},{"name":"Iff.trans","description":""},{"name":"Iff.symm","description":""},{"name":"Iff.comm","description":""},{"name":"Exists.elim","description":""},{"name":"decide_true_eq_true","description":""},{"name":"decide_false_eq_false","description":""},{"name":"toBoolUsing","description":"Similar to `decide`, but uses an explicit instance "},{"name":"toBoolUsing_eq_true","description":""},{"name":"ofBoolUsing_eq_true","description":""},{"name":"ofBoolUsing_eq_false","description":""},{"name":"instDecidableTrue","description":""},{"name":"instDecidableFalse","description":""},{"name":"Decidable.byCases","description":""},{"name":"Decidable.em","description":""},{"name":"Decidable.byContradiction","description":""},{"name":"Decidable.of_not_not","description":""},{"name":"Decidable.not_and_iff_or_not","description":""},{"name":"decidable_of_decidable_of_iff","description":""},{"name":"decidable_of_decidable_of_eq","description":""},{"name":"instDecidableForAll","description":""},{"name":"instDecidableIff","description":""},{"name":"if_pos","description":""},{"name":"if_neg","description":""},{"name":"dif_pos","description":""},{"name":"dif_neg","description":""},{"name":"dif_eq_if","description":""},{"name":"instDecidableIteProp","description":""},{"name":"instDecidableDitePropNot","description":""},{"name":"noConfusionTypeEnum","description":""},{"name":"noConfusionEnum","description":""},{"name":"instInhabitedProp","description":""},{"name":"instInhabitedForInStep","description":""},{"name":"instInhabitedPNonScalar","description":""},{"name":"instInhabitedTrue","description":""},{"name":"instInhabitedNonScalar","description":""},{"name":"nonempty_of_exists","description":""},{"name":"Subsingleton","description":""},{"name":"Subsingleton.elim","description":""},{"name":"Subsingleton.helim","description":""},{"name":"instSubsingleton","description":""},{"name":"instSubsingletonDecidable","description":""},{"name":"recSubsingleton","description":""},{"name":"Equivalence","description":""},{"name":"emptyRelation","description":""},{"name":"Subrelation","description":""},{"name":"InvImage","description":""},{"name":"TC","description":""},{"name":"Subtype.existsOfSubtype","description":""},{"name":"Subtype.eq","description":""},{"name":"Subtype.eta","description":""},{"name":"Subtype.instInhabitedSubtype","description":""},{"name":"Subtype.instDecidableEqSubtype","description":""},{"name":"Sum.inhabitedLeft","description":""},{"name":"Sum.inhabitedRight","description":""},{"name":"instDecidableEqSum","description":""},{"name":"instInhabitedProd","description":""},{"name":"instDecidableEqProd","description":""},{"name":"instBEqProd","description":""},{"name":"instLTProd","description":""},{"name":"prodHasDecidableLt","description":""},{"name":"Prod.lt_def","description":""},{"name":"Prod.ext","description":""},{"name":"Prod.map","description":""},{"name":"ex_of_PSigma","description":""},{"name":"PSigma.eta","description":""},{"name":"PUnit.subsingleton","description":""},{"name":"PUnit.eq_punit","description":""},{"name":"instSubsingletonPUnit","description":""},{"name":"instInhabitedPUnit","description":""},{"name":"instDecidableEqPUnit","description":""},{"name":"Setoid","description":""},{"name":"instHasEquiv","description":""},{"name":"Setoid.refl","description":""},{"name":"Setoid.symm","description":""},{"name":"Setoid.trans","description":""},{"name":"propext","description":""},{"name":"Eq.propIntro","description":""},{"name":"instDecidableEqProp","description":""},{"name":"Iff.subst","description":""},{"name":"Quot.sound","description":""},{"name":"Quot.liftBeta","description":""},{"name":"Quot.indBeta","description":""},{"name":"Quot.liftOn","description":""},{"name":"Quot.inductionOn","description":""},{"name":"Quot.exists_rep","description":""},{"name":"Quot.indep","description":""},{"name":"Quot.indepCoherent","description":""},{"name":"Quot.liftIndepPr1","description":""},{"name":"Quot.rec","description":""},{"name":"Quot.recOn","description":""},{"name":"Quot.recOnSubsingleton","description":""},{"name":"Quot.hrecOn","description":""},{"name":"Quotient","description":""},{"name":"Quotient.mk","description":""},{"name":"Quotient.mk'","description":""},{"name":"Quotient.sound","description":""},{"name":"Quotient.lift","description":""},{"name":"Quotient.ind","description":""},{"name":"Quotient.liftOn","description":""},{"name":"Quotient.inductionOn","description":""},{"name":"Quotient.exists_rep","description":""},{"name":"Quotient.rec","description":""},{"name":"Quotient.recOn","description":""},{"name":"Quotient.recOnSubsingleton","description":""},{"name":"Quotient.hrecOn","description":""},{"name":"Quotient.lift‚ÇÇ","description":""},{"name":"Quotient.liftOn‚ÇÇ","description":""},{"name":"Quotient.ind‚ÇÇ","description":""},{"name":"Quotient.inductionOn‚ÇÇ","description":""},{"name":"Quotient.inductionOn‚ÇÉ","description":""},{"name":"Quotient.exact","description":""},{"name":"Quotient.recOnSubsingleton‚ÇÇ","description":""},{"name":"instDecidableEqQuotient","description":""},{"name":"Function.Equiv","description":""},{"name":"Function.Equiv.refl","description":""},{"name":"Function.Equiv.symm","description":""},{"name":"Function.Equiv.trans","description":""},{"name":"Function.Equiv.isEquivalence","description":""},{"name":"funext","description":""},{"name":"instSubsingletonForAll","description":""},{"name":"Squash","description":""},{"name":"Squash.mk","description":""},{"name":"Squash.ind","description":""},{"name":"Squash.lift","description":""},{"name":"instSubsingletonSquash","description":""},{"name":"Antisymm","description":""},{"name":"Lean.reduceBool","description":"When the kernel tries to reduce a term `Lean.reduceBool c`, it will invoke the Lean interpreter to evaluate `c`.\n  The kernel will not use the interpreter if `c` is not a constant.\n  This feature is useful for performing proofs by reflection.\n\n  Remark: the Lean frontend allows terms of the from `Lean.reduceBool t` where `t` is a term not containing\n  free variables. The frontend automatically declares a fresh auxiliary constant `c` and replaces the term with\n  `Lean.reduceBool c`. The main motivation is that the code for `t` will be pre-compiled.\n\n  Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\n  This is extra 30k lines of code. More importantly, you will probably not be able to check your developement using\n  external type checkers (e.g., Trepplein) that do not implement this feature.\n  Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\n  So, you are mainly losing the capability of type checking your developement using external checkers.\n\n  Recall that the compiler trusts the correctness of all `[implementedBy ...]` and `[extern ...]` annotations.\n  If an extern function is executed, then the trusted code base will also include the implementation of the associated\n  foreign function.\n"},{"name":"Lean.reduceNat","description":"Similar to `Lean.reduceBool` for closed `Nat` terms.\n\n  Remark: we do not have plans for supporting a generic `reduceValue {Œ±} (a : Œ±) : Œ± := a`.\n  The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.\n  We believe `Lean.reduceBool` enables most interesting applications (e.g., proof by reflection). "},{"name":"Lean.ofReduceBool","description":""},{"name":"Lean.ofReduceNat","description":""},{"name":"Lean.IsAssociative","description":""},{"name":"Lean.IsCommutative","description":""},{"name":"Lean.IsIdempotent","description":""},{"name":"Lean.IsNeutral","description":""},{"name":"Array.binSearchAux","description":""},{"name":"Array.binSearch","description":""},{"name":"Array.binSearchContains","description":""},{"name":"Array.binInsertM","description":""},{"name":"Array.binInsert","description":""},{"name":"Classical.indefiniteDescription","description":""},{"name":"Classical.choose","description":""},{"name":"Classical.choose_spec","description":""},{"name":"Classical.em","description":"Diaconescu's theorem: excluded middle from choice, Function extensionality and propositional extensionality. "},{"name":"Classical.exists_true_of_nonempty","description":""},{"name":"Classical.inhabited_of_nonempty","description":""},{"name":"Classical.inhabited_of_exists","description":""},{"name":"Classical.propDecidable","description":""},{"name":"Classical.decidableInhabited","description":""},{"name":"Classical.typeDecidableEq","description":""},{"name":"Classical.typeDecidable","description":""},{"name":"Classical.strongIndefiniteDescription","description":""},{"name":"Classical.epsilon","description":"the Hilbert epsilon Function "},{"name":"Classical.epsilon_spec_aux","description":""},{"name":"Classical.epsilon_spec","description":""},{"name":"Classical.epsilon_singleton","description":""},{"name":"Classical.axiomOfChoice","description":"the axiom of choice "},{"name":"Classical.skolem","description":""},{"name":"Classical.propComplete","description":""},{"name":"Classical.byCases","description":""},{"name":"Classical.byContradiction","description":""},{"name":"Classical.¬´tacticBy_cases__:_¬ª","description":"`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬¨ p` in the second branch.\n"},{"name":"StateT","description":""},{"name":"StateT.run","description":""},{"name":"StateT.run'","description":""},{"name":"StateM","description":""},{"name":"instSubsingletonStateM","description":""},{"name":"StateT.pure","description":""},{"name":"StateT.bind","description":""},{"name":"StateT.map","description":""},{"name":"StateT.instMonadStateT","description":""},{"name":"StateT.orElse","description":""},{"name":"StateT.failure","description":""},{"name":"StateT.instAlternativeStateT","description":""},{"name":"StateT.get","description":""},{"name":"StateT.set","description":""},{"name":"StateT.modifyGet","description":""},{"name":"StateT.lift","description":""},{"name":"StateT.instMonadLiftStateT","description":""},{"name":"StateT.instMonadFunctorStateT","description":""},{"name":"StateT.instMonadExceptOfStateT","description":""},{"name":"instMonadStateOfStateT","description":""},{"name":"StateT.monadControl","description":""},{"name":"StateT.tryFinally","description":""},{"name":"Nat.div_rec_lemma","description":""},{"name":"Nat.div","description":""},{"name":"Nat.instDivNat","description":""},{"name":"Nat.div_eq","description":""},{"name":"Nat.div.inductionOn","description":""},{"name":"Nat.div_le_self","description":""},{"name":"Nat.div_lt_self","description":""},{"name":"Nat.mod","description":""},{"name":"Nat.instModNat","description":""},{"name":"Nat.mod_eq","description":""},{"name":"Nat.mod.inductionOn","description":""},{"name":"Nat.mod_zero","description":""},{"name":"Nat.mod_eq_of_lt","description":""},{"name":"Nat.mod_eq_sub_mod","description":""},{"name":"Nat.mod_lt","description":""},{"name":"Nat.mod_le","description":""},{"name":"Nat.zero_mod","description":""},{"name":"Nat.mod_self","description":""},{"name":"Nat.mod_one","description":""},{"name":"Nat.div_add_mod","description":""},{"name":"StateCpsT","description":""},{"name":"StateCpsT.runK","description":""},{"name":"StateCpsT.run","description":""},{"name":"StateCpsT.run'","description":""},{"name":"StateCpsT.instMonadStateCpsT","description":""},{"name":"StateCpsT.instLawfulMonadStateCpsTInstMonadStateCpsT","description":""},{"name":"StateCpsT.instMonadStateOfStateCpsT","description":""},{"name":"StateCpsT.lift","description":""},{"name":"StateCpsT.instMonadLiftStateCpsT","description":""},{"name":"StateCpsT.runK_pure","description":""},{"name":"StateCpsT.runK_get","description":""},{"name":"StateCpsT.runK_set","description":""},{"name":"StateCpsT.runK_modify","description":""},{"name":"StateCpsT.runK_lift","description":""},{"name":"StateCpsT.runK_monadLift","description":""},{"name":"StateCpsT.runK_bind_pure","description":""},{"name":"StateCpsT.runK_bind_lift","description":""},{"name":"StateCpsT.runK_bind_get","description":""},{"name":"StateCpsT.runK_bind_set","description":""},{"name":"StateCpsT.runK_bind_modify","description":""},{"name":"StateCpsT.run_eq","description":""},{"name":"StateCpsT.run'_eq","description":""},{"name":"IO.RealWorld","description":"Like https://hackage.haskell.org/package/ghc-Prim-0.5.2.0/docs/GHC-Prim.html#t:RealWorld.\n    Makes sure we never reorder `IO` operations.\n\n    TODO: mark opaque "},{"name":"EIO","description":""},{"name":"instMonadEIO","description":""},{"name":"instMonadFinallyEIO","description":""},{"name":"instMonadExceptOfEIO","description":""},{"name":"instOrElseEIO","description":""},{"name":"instInhabitedEIO","description":""},{"name":"BaseIO","description":"An `EIO` monad that cannot throw exceptions. "},{"name":"instMonadBaseIO","description":""},{"name":"instMonadFinallyBaseIO","description":""},{"name":"BaseIO.toEIO","description":""},{"name":"instMonadLiftBaseIOEIO","description":""},{"name":"EIO.toBaseIO","description":""},{"name":"EIO.catchExceptions","description":""},{"name":"IO","description":""},{"name":"BaseIO.toIO","description":""},{"name":"EIO.toIO","description":""},{"name":"EIO.toIO'","description":""},{"name":"IO.toEIO","description":""},{"name":"unsafeBaseIO","description":""},{"name":"unsafeEIO","description":""},{"name":"unsafeIO","description":""},{"name":"timeit","description":""},{"name":"allocprof","description":""},{"name":"IO.initializing","description":""},{"name":"BaseIO.asTask","description":"Run `act` in a separate `Task`.\n  This is similar to Haskell's [`unsafeInterleaveIO`](http://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO),\n  except that the `Task` is started eagerly as usual. Thus pure accesses to the `Task` do not influence the impure `act`\n  computation.\n  Unlike with pure tasks created by `Task.spawn`, tasks created by this function will be run even if the last reference\n  to the task is dropped. The `act` should manually check for cancellation via `IO.checkCanceled` if it wants to react\n  to that. "},{"name":"BaseIO.mapTask","description":"See `BaseIO.asTask`. "},{"name":"BaseIO.bindTask","description":"See `BaseIO.asTask`. "},{"name":"BaseIO.mapTasks","description":""},{"name":"BaseIO.mapTasks.go","description":""},{"name":"EIO.asTask","description":"`EIO` specialization of `BaseIO.asTask`. "},{"name":"EIO.mapTask","description":"`EIO` specialization of `BaseIO.mapTask`. "},{"name":"EIO.bindTask","description":"`EIO` specialization of `BaseIO.bindTask`. "},{"name":"EIO.mapTasks","description":"`EIO` specialization of `BaseIO.mapTasks`. "},{"name":"IO.ofExcept","description":""},{"name":"IO.lazyPure","description":""},{"name":"IO.monoMsNow","description":"Monotonically increasing time since an unspecified past point in milliseconds. No relation to wall clock time. "},{"name":"IO.monoNanosNow","description":"Monotonically increasing time since an unspecified past point in nanoseconds. No relation to wall clock time. "},{"name":"IO.getRandomBytes","description":"Read bytes from a system entropy source. Not guaranteed to be cryptographically secure.\nIf `nBytes = 0`, return immediately with an empty buffer. "},{"name":"IO.sleep","description":""},{"name":"IO.asTask","description":"`IO` specialization of `EIO.asTask`. "},{"name":"IO.mapTask","description":"`IO` specialization of `EIO.mapTask`. "},{"name":"IO.bindTask","description":"`IO` specialization of `EIO.bindTask`. "},{"name":"IO.mapTasks","description":"`IO` specialization of `EIO.mapTasks`. "},{"name":"IO.checkCanceled","description":"Check if the task's cancellation flag has been set by calling `IO.cancel` or dropping the last reference to the task. "},{"name":"IO.cancel","description":"Request cooperative cancellation of the task. The task must explicitly call `IO.checkCanceled` to react to the cancellation. "},{"name":"IO.hasFinished","description":"Check if the task has finished execution, at which point calling `Task.get` will return immediately. "},{"name":"IO.wait","description":"Wait for the task to finish, then return its result. "},{"name":"IO.waitAny","description":"Wait until any of the tasks in the given list has finished, then return its result. "},{"name":"IO.getNumHeartbeats","description":"Helper method for implementing \"deterministic\" timeouts. It is the number of \"small\" memory allocations performed by the current execution thread. "},{"name":"IO.FS.Mode","description":""},{"name":"IO.FS.Handle","description":""},{"name":"IO.FS.Stream","description":"A pure-Lean abstraction of POSIX streams. We use `Stream`s for the standard streams stdin/stdout/stderr so we can\n  capture output of `#eval` commands into memory. "},{"name":"IO.FS.instInhabitedStream","description":""},{"name":"IO.getStdin","description":""},{"name":"IO.getStdout","description":""},{"name":"IO.getStderr","description":""},{"name":"IO.setStdin","description":"Replaces the stdin stream of the current thread and returns its previous value. "},{"name":"IO.setStdout","description":"Replaces the stdout stream of the current thread and returns its previous value. "},{"name":"IO.setStderr","description":"Replaces the stderr stream of the current thread and returns its previous value. "},{"name":"IO.iterate","description":""},{"name":"IO.FS.Handle.mkPrim","description":""},{"name":"IO.FS.Handle.mk","description":""},{"name":"IO.FS.Handle.isEof","description":"Returns whether the end of the file has been reached while reading a file.\n`h.isEof` returns true /after/ the first attempt at reading past the end of `h`.\nOnce `h.isEof` is true, reading `h` will always return an empty array.\n"},{"name":"IO.FS.Handle.flush","description":""},{"name":"IO.FS.Handle.read","description":""},{"name":"IO.FS.Handle.write","description":""},{"name":"IO.FS.Handle.getLine","description":""},{"name":"IO.FS.Handle.putStr","description":""},{"name":"IO.FS.realPath","description":""},{"name":"IO.FS.removeFile","description":""},{"name":"IO.FS.removeDir","description":"Remove given directory. Fails if not empty; see also `IO.FS.removeDirAll`. "},{"name":"IO.FS.createDir","description":""},{"name":"IO.getEnv","description":""},{"name":"IO.appPath","description":""},{"name":"IO.currentDir","description":""},{"name":"IO.FS.withFile","description":""},{"name":"IO.FS.Handle.putStrLn","description":""},{"name":"IO.FS.Handle.readBinToEnd","description":""},{"name":"IO.FS.Handle.readBinToEnd.loop","description":""},{"name":"IO.FS.Handle.readToEnd","description":""},{"name":"IO.FS.Handle.readToEnd.loop","description":""},{"name":"IO.FS.readBinFile","description":""},{"name":"IO.FS.readFile","description":""},{"name":"IO.FS.lines","description":""},{"name":"IO.FS.lines.read","description":""},{"name":"IO.FS.writeBinFile","description":""},{"name":"IO.FS.writeFile","description":""},{"name":"IO.FS.Stream.putStrLn","description":""},{"name":"IO.FS.DirEntry","description":""},{"name":"IO.FS.instReprDirEntry","description":""},{"name":"IO.FS.DirEntry.path","description":""},{"name":"IO.FS.FileType","description":""},{"name":"IO.FS.instReprFileType","description":""},{"name":"IO.FS.instBEqFileType","description":""},{"name":"IO.FS.SystemTime","description":""},{"name":"IO.FS.instReprSystemTime","description":""},{"name":"IO.FS.instBEqSystemTime","description":""},{"name":"IO.FS.instOrdSystemTime","description":""},{"name":"IO.FS.instInhabitedSystemTime","description":""},{"name":"IO.FS.instLTSystemTime","description":""},{"name":"IO.FS.instLESystemTime","description":""},{"name":"IO.FS.Metadata","description":""},{"name":"IO.FS.instReprMetadata","description":""},{"name":"System.FilePath.readDir","description":""},{"name":"System.FilePath.metadata","description":""},{"name":"System.FilePath.isDir","description":""},{"name":"System.FilePath.pathExists","description":""},{"name":"System.FilePath.walkDir","description":"Return all filesystem entries of a preorder traversal of all directories satisfying `enter`, starting at `p`.\n  Symbolic links are visited as well by default. "},{"name":"System.FilePath.walkDir.go","description":""},{"name":"IO.withStdin","description":""},{"name":"IO.withStdout","description":""},{"name":"IO.withStderr","description":""},{"name":"IO.print","description":""},{"name":"IO.println","description":""},{"name":"IO.eprint","description":""},{"name":"IO.eprintln","description":""},{"name":"IO.appDir","description":""},{"name":"IO.FS.createDirAll","description":"Create given path and all missing parents as directories. "},{"name":"IO.FS.removeDirAll","description":"Fully remove given directory by deleting all contained files and directories in an unspecified order.\n  Fails if any contained entry cannot be deleted or was newly created during execution. "},{"name":"IO.Process.Stdio","description":""},{"name":"IO.Process.Stdio.toHandleType","description":""},{"name":"IO.Process.StdioConfig","description":""},{"name":"IO.Process.SpawnArgs","description":""},{"name":"IO.Process.Child","description":""},{"name":"IO.Process.spawn","description":""},{"name":"IO.Process.Child.wait","description":""},{"name":"IO.Process.Child.takeStdin","description":"Extract the `stdin` field from a `Child` object, allowing them to be freed independently.\nThis operation is necessary for closing the child process' stdin while still holding on to a process handle,\ne.g. for `Child.wait`. A file handle is closed when all references to it are dropped, which without this\noperation includes the `Child` object.\n"},{"name":"IO.Process.Output","description":""},{"name":"IO.Process.output","description":"Run process to completion and capture output. "},{"name":"IO.Process.run","description":"Run process to completion and return stdout on success. "},{"name":"IO.Process.exit","description":""},{"name":"IO.AccessRight","description":""},{"name":"IO.AccessRight.flags","description":""},{"name":"IO.FileRight","description":""},{"name":"IO.FileRight.flags","description":""},{"name":"IO.Prim.setAccessRights","description":""},{"name":"IO.setAccessRights","description":""},{"name":"IO.Ref","description":""},{"name":"IO.instMonadLiftSTRealWorldBaseIO","description":""},{"name":"IO.mkRef","description":""},{"name":"IO.FS.Stream.ofHandle","description":""},{"name":"IO.FS.Stream.Buffer","description":""},{"name":"IO.FS.Stream.ofBuffer","description":""},{"name":"IO.FS.withIsolatedStreams","description":"Run action with `stdin` emptied and `stdout+stderr` captured into a `String`. "},{"name":"Lean.Eval","description":"Typeclass used for presenting the output of an `#eval` command. "},{"name":"Lean.instEval","description":""},{"name":"Lean.instEval_1","description":""},{"name":"Lean.instEvalUnit","description":""},{"name":"Lean.instEvalIO","description":""},{"name":"Lean.runEval","description":""},{"name":"termPrintln!__","description":""},{"name":"Repr","description":""},{"name":"repr","description":""},{"name":"reprStr","description":""},{"name":"reprArg","description":""},{"name":"ReprAtom","description":""},{"name":"instReprIdType","description":""},{"name":"instReprId","description":""},{"name":"instReprBool","description":""},{"name":"Repr.addAppParen","description":""},{"name":"instReprDecidable","description":""},{"name":"instReprPUnit","description":""},{"name":"instReprULift","description":""},{"name":"instReprUnit","description":""},{"name":"instReprOption","description":""},{"name":"instReprSum","description":""},{"name":"ReprTuple","description":""},{"name":"instReprTuple","description":""},{"name":"instReprTupleProd","description":""},{"name":"instReprProd","description":""},{"name":"instReprSigma","description":""},{"name":"instReprSubtype","description":""},{"name":"Nat.digitChar","description":""},{"name":"Nat.toDigitsCore","description":""},{"name":"Nat.toDigits","description":""},{"name":"Nat.repr","description":""},{"name":"Nat.superDigitChar","description":""},{"name":"Nat.toSuperDigitsAux","description":""},{"name":"Nat.toSuperDigits","description":""},{"name":"Nat.toSuperscriptString","description":""},{"name":"instReprNat","description":""},{"name":"Int.repr","description":""},{"name":"instReprInt","description":""},{"name":"hexDigitRepr","description":""},{"name":"charToHex","description":""},{"name":"Char.quoteCore","description":""},{"name":"Char.quote","description":""},{"name":"instReprChar","description":""},{"name":"Char.repr","description":""},{"name":"String.quote","description":""},{"name":"instReprString","description":""},{"name":"instReprPos","description":""},{"name":"instReprSubstring","description":""},{"name":"instReprIterator","description":""},{"name":"instReprFin","description":""},{"name":"instReprUInt8","description":""},{"name":"instReprUInt16","description":""},{"name":"instReprUInt32","description":""},{"name":"instReprUInt64","description":""},{"name":"instReprUSize","description":""},{"name":"instReprList","description":""},{"name":"instReprList_1","description":""},{"name":"instReprAtomBool","description":""},{"name":"instReprAtomNat","description":""},{"name":"instReprAtomInt","description":""},{"name":"instReprAtomChar","description":""},{"name":"instReprAtomString","description":""},{"name":"instReprAtomUInt8","description":""},{"name":"instReprAtomUInt16","description":""},{"name":"instReprAtomUInt32","description":""},{"name":"instReprAtomUInt64","description":""},{"name":"instReprAtomUSize","description":""},{"name":"instReprSourceInfo","description":""},{"name":"ToStream","description":""},{"name":"Stream","description":""},{"name":"Stream.forIn","description":""},{"name":"Stream.forIn.visit","description":""},{"name":"instForIn","description":""},{"name":"instToStreamList","description":""},{"name":"instToStreamArraySubarray","description":""},{"name":"instToStreamSubarray","description":""},{"name":"instToStreamStringSubstring","description":""},{"name":"instToStreamRange","description":""},{"name":"instStreamProdProd","description":""},{"name":"instStreamList","description":""},{"name":"instStreamSubarray","description":""},{"name":"instStreamRangeNat","description":""},{"name":"instStreamSubstringChar","description":""},{"name":"Coe","description":""},{"name":"CoeTC","description":"Auxiliary class that contains the transitive closure of `Coe`. "},{"name":"CoeHead","description":""},{"name":"CoeTail","description":""},{"name":"CoeHTCT","description":"Auxiliary class that contains `CoeHead` + `CoeTC` + `CoeTail`. "},{"name":"CoeDep","description":""},{"name":"CoeT","description":""},{"name":"CoeFun","description":""},{"name":"CoeSort","description":""},{"name":"coeNotation","description":""},{"name":"coeTrans","description":""},{"name":"coeBase","description":""},{"name":"coeOfHeafOfTCOfTail","description":""},{"name":"coeOfHeadOfTC","description":""},{"name":"coeOfTCOfTail","description":""},{"name":"coeOfHead","description":""},{"name":"coeOfTail","description":""},{"name":"coeOfTC","description":""},{"name":"coeOfHTCT","description":""},{"name":"coeOfDep","description":""},{"name":"coeId","description":""},{"name":"coeSortToCoeTail","description":""},{"name":"boolToProp","description":""},{"name":"boolToSort","description":""},{"name":"decPropToBool","description":""},{"name":"optionCoe","description":""},{"name":"subtypeCoe","description":""},{"name":"Lean.Internal.liftCoeM","description":""},{"name":"Lean.Internal.coeM","description":""},{"name":"instCoeDep","description":""},{"name":"instCoeTail","description":""},{"name":"instCoeTail_1","description":""},{"name":"Std.Range","description":""},{"name":"Std.instMembershipNatRange","description":""},{"name":"Std.Range.forIn","description":""},{"name":"Std.Range.forIn.loop","description":""},{"name":"Std.Range.instForInRangeNat","description":""},{"name":"Std.Range.forIn'","description":""},{"name":"Std.Range.forIn'.loop","description":""},{"name":"Std.Range.instForIn'RangeNatInferInstanceMembershipInstMembershipNatRange","description":""},{"name":"Std.Range.forM","description":""},{"name":"Std.Range.forM.loop","description":""},{"name":"Std.Range.instForMRangeNat","description":""},{"name":"Std.Range.¬´term[:_]¬ª","description":""},{"name":"Std.Range.¬´term[_:_]¬ª","description":""},{"name":"Std.Range.¬´term[:_:_]¬ª","description":""},{"name":"Std.Range.¬´term[_:_:_]¬ª","description":""},{"name":"Membership.mem.upper","description":""},{"name":"Membership.mem.lower","description":""},{"name":"instToBoolOption","description":""},{"name":"OptionT","description":""},{"name":"OptionT.run","description":""},{"name":"OptionT.mk","description":""},{"name":"OptionT.bind","description":""},{"name":"OptionT.pure","description":""},{"name":"OptionT.instMonadOptionT","description":""},{"name":"OptionT.orElse","description":""},{"name":"OptionT.fail","description":""},{"name":"OptionT.instAlternativeOptionT","description":""},{"name":"OptionT.lift","description":""},{"name":"OptionT.instMonadLiftOptionT","description":""},{"name":"OptionT.instMonadFunctorOptionT","description":""},{"name":"OptionT.tryCatch","description":""},{"name":"OptionT.instMonadExceptOfUnitOptionT","description":""},{"name":"OptionT.instMonadExceptOfOptionT","description":""},{"name":"instMonadControlOptionT","description":""},{"name":"FloatSpec","description":""},{"name":"floatSpec","description":""},{"name":"Float","description":""},{"name":"instInhabitedFloat","description":""},{"name":"Float.add","description":""},{"name":"Float.sub","description":""},{"name":"Float.mul","description":""},{"name":"Float.div","description":""},{"name":"Float.neg","description":""},{"name":"Float.lt","description":""},{"name":"Float.le","description":""},{"name":"instAddFloat","description":""},{"name":"instSubFloat","description":""},{"name":"instMulFloat","description":""},{"name":"instDivFloat","description":""},{"name":"instNegFloat","description":""},{"name":"instLTFloat","description":""},{"name":"instLEFloat","description":""},{"name":"Float.beq","description":""},{"name":"instBEqFloat","description":""},{"name":"Float.decLt","description":""},{"name":"Float.decLe","description":""},{"name":"floatDecLt","description":""},{"name":"floatDecLe","description":""},{"name":"Float.toString","description":""},{"name":"Float.toUInt8","description":""},{"name":"Float.toUInt16","description":""},{"name":"Float.toUInt32","description":""},{"name":"Float.toUInt64","description":""},{"name":"Float.toUSize","description":""},{"name":"instToStringFloat","description":""},{"name":"instReprFloat","description":""},{"name":"instReprAtomFloat","description":""},{"name":"UInt64.toFloat","description":""},{"name":"Float.sin","description":""},{"name":"Float.cos","description":""},{"name":"Float.tan","description":""},{"name":"Float.asin","description":""},{"name":"Float.acos","description":""},{"name":"Float.atan","description":""},{"name":"Float.atan2","description":""},{"name":"Float.sinh","description":""},{"name":"Float.cosh","description":""},{"name":"Float.tanh","description":""},{"name":"Float.asinh","description":""},{"name":"Float.acosh","description":""},{"name":"Float.atanh","description":""},{"name":"Float.exp","description":""},{"name":"Float.exp2","description":""},{"name":"Float.log","description":""},{"name":"Float.log2","description":""},{"name":"Float.log10","description":""},{"name":"Float.pow","description":""},{"name":"Float.sqrt","description":""},{"name":"Float.cbrt","description":""},{"name":"instPowFloat","description":""},{"name":"Float.scaleB","description":"Efficiently computes `x * 2^i`.\n"},{"name":"String.toNat!","description":""},{"name":"String.fromUTF8Unchecked","description":"Convert a UTF-8 encoded `ByteArray` string to `String`.\n  The result is unspecified if `a` is not properly UTF-8 encoded. "},{"name":"String.toUTF8","description":""},{"name":"String.one_le_csize","description":""},{"name":"String.pos_lt_eq","description":""},{"name":"String.pos_add_char","description":""},{"name":"String.eq_empty_of_bsize_eq_zero","description":""},{"name":"String.lt_next","description":""},{"name":"String.Iterator.sizeOf_next_lt_of_hasNext","description":""},{"name":"String.Iterator.sizeOf_next_lt_of_atEnd","description":""},{"name":"Ordering","description":""},{"name":"instInhabitedOrdering","description":""},{"name":"instBEqOrdering","description":""},{"name":"Ord","description":""},{"name":"compareOfLessAndEq","description":""},{"name":"instOrdNat","description":""},{"name":"instOrdInt","description":""},{"name":"instOrdBool","description":""},{"name":"instOrdString","description":""},{"name":"instOrdFin","description":""},{"name":"instOrdUInt8","description":""},{"name":"instOrdUInt16","description":""},{"name":"instOrdUInt32","description":""},{"name":"instOrdUInt64","description":""},{"name":"instOrdUSize","description":""},{"name":"instOrdChar","description":""},{"name":"ltOfOrd","description":""},{"name":"instDecidableRelLtLtOfOrd","description":""},{"name":"Ordering.isLE","description":""},{"name":"leOfOrd","description":""},{"name":"instDecidableRelLeLeOfOrd","description":""},{"name":"EStateM.instToStringResult","description":""},{"name":"EStateM.instReprResult","description":""},{"name":"EStateM.orElse'","description":"Alternative orElse operator that allows to select which exception should be used.\n    The default is to use the first exception since the standard `orElse` uses the second. "},{"name":"EStateM.instMonadFinallyEStateM","description":""},{"name":"EStateM.fromStateM","description":""},{"name":"isValidChar","description":""},{"name":"Char.lt","description":""},{"name":"Char.le","description":""},{"name":"Char.instLTChar","description":""},{"name":"Char.instLEChar","description":""},{"name":"Char.instDecidableLtCharInstLTChar","description":""},{"name":"Char.instDecidableLeCharInstLEChar","description":""},{"name":"Char.isValidCharNat","description":""},{"name":"Char.isValidUInt32","description":""},{"name":"Char.isValidChar_of_isValidChar_Nat","description":""},{"name":"Char.isValidChar_zero","description":""},{"name":"Char.toNat","description":""},{"name":"Char.instInhabitedChar","description":""},{"name":"Char.isWhitespace","description":""},{"name":"Char.isUpper","description":""},{"name":"Char.isLower","description":""},{"name":"Char.isAlpha","description":""},{"name":"Char.isDigit","description":""},{"name":"Char.isAlphanum","description":""},{"name":"Char.toLower","description":""},{"name":"Char.toUpper","description":""},{"name":"Lean.Parser.Tactic.Conv.conv.quot","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeq1Indented","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeqBracketed","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeq","description":""},{"name":"Lean.Parser.Tactic.Conv.conv","description":""},{"name":"Lean.Parser.Tactic.Conv.lhs","description":""},{"name":"Lean.Parser.Tactic.Conv.rhs","description":""},{"name":"Lean.Parser.Tactic.Conv.whnf","description":""},{"name":"Lean.Parser.Tactic.Conv.reduce","description":"Put term in normal form, this tactic is ment for debugging purposes only "},{"name":"Lean.Parser.Tactic.Conv.congr","description":""},{"name":"Lean.Parser.Tactic.Conv.arg","description":""},{"name":"Lean.Parser.Tactic.Conv.ext","description":""},{"name":"Lean.Parser.Tactic.Conv.change","description":""},{"name":"Lean.Parser.Tactic.Conv.delta","description":""},{"name":"Lean.Parser.Tactic.Conv.unfold","description":""},{"name":"Lean.Parser.Tactic.Conv.pattern","description":""},{"name":"Lean.Parser.Tactic.Conv.rewrite","description":""},{"name":"Lean.Parser.Tactic.Conv.simp","description":""},{"name":"Lean.Parser.Tactic.Conv.simpMatch","description":""},{"name":"Lean.Parser.Tactic.Conv.nestedTacticCore","description":"Execute the given tactic block without converting `conv` goal into a regular goal "},{"name":"Lean.Parser.Tactic.Conv.nestedTactic","description":"Focus, convert the `conv` goal `‚ä¢ lhs` into a regular goal `‚ä¢ lhs = rhs`, and then execute the given tactic block. "},{"name":"Lean.Parser.Tactic.Conv.nestedConv","description":""},{"name":"Lean.Parser.Tactic.Conv.paren","description":""},{"name":"Lean.Parser.Tactic.Conv.convConvSeq","description":""},{"name":"Lean.Parser.Tactic.Conv.¬´conv¬∑._¬ª","description":"`¬∑ conv` focuses on the main conv goal and tries to solve it using `s` "},{"name":"Lean.Parser.Tactic.Conv.convRw__","description":""},{"name":"Lean.Parser.Tactic.Conv.convErw_","description":""},{"name":"Lean.Parser.Tactic.Conv.convArgs","description":""},{"name":"Lean.Parser.Tactic.Conv.convLeft","description":""},{"name":"Lean.Parser.Tactic.Conv.convRight","description":""},{"name":"Lean.Parser.Tactic.Conv.convIntro___","description":""},{"name":"Lean.Parser.Tactic.Conv.enterArg","description":""},{"name":"Lean.Parser.Tactic.Conv.¬´convEnter[__]¬ª","description":""},{"name":"Lean.Parser.Tactic.Conv.convSkip","description":""},{"name":"Lean.Parser.Tactic.Conv.convDone","description":""},{"name":"Lean.Parser.Tactic.Conv.convTrace_state","description":""},{"name":"Lean.Parser.Tactic.Conv.convApply_","description":""},{"name":"Lean.Parser.Tactic.Conv.first","description":"`first | conv | ...` runs each `conv` until one succeeds, or else fails. "},{"name":"Lean.Parser.Tactic.Conv.convRepeat_","description":""},{"name":"instToFormat","description":""},{"name":"List.format","description":""},{"name":"instToFormatList","description":""},{"name":"instToFormatArray","description":""},{"name":"Option.format","description":""},{"name":"instToFormatOption","description":""},{"name":"instToFormatProd","description":""},{"name":"String.toFormat","description":""},{"name":"instToFormatPos","description":""},{"name":"Id","description":""},{"name":"Id.instMonadId","description":""},{"name":"Id.hasBind","description":""},{"name":"Id.run","description":""},{"name":"Id.instOfNatId","description":""},{"name":"id","description":""},{"name":"Function.comp","description":""},{"name":"Function.const","description":""},{"name":"inferInstance","description":""},{"name":"inferInstanceAs","description":""},{"name":"PUnit","description":""},{"name":"Unit","description":"An abbreviation for `PUnit.{0}`, its most common instantiation.\n    This Type should be preferred over `PUnit` where possible to avoid\n    unnecessary universe parameters. "},{"name":"Unit.unit","description":""},{"name":"lcProof","description":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code. "},{"name":"lcUnreachable","description":"Auxiliary unsafe constant used by the Compiler to mark unreachable code. "},{"name":"True","description":""},{"name":"False","description":""},{"name":"Empty","description":""},{"name":"PEmpty","description":""},{"name":"Not","description":""},{"name":"False.elim","description":""},{"name":"absurd","description":""},{"name":"Eq","description":""},{"name":"rfl","description":""},{"name":"id_eq","description":""},{"name":"Eq.subst","description":""},{"name":"Eq.symm","description":""},{"name":"Eq.trans","description":""},{"name":"cast","description":""},{"name":"congrArg","description":""},{"name":"congr","description":""},{"name":"congrFun","description":""},{"name":"HEq","description":""},{"name":"HEq.rfl","description":""},{"name":"eq_of_heq","description":""},{"name":"Prod","description":""},{"name":"PProd","description":"Similar to `Prod`, but `Œ±` and `Œ≤` can be propositions.\n   We use this Type internally to automatically generate the brecOn recursor. "},{"name":"MProd","description":"Similar to `Prod`, but `Œ±` and `Œ≤` are in the same universe. "},{"name":"And","description":""},{"name":"Or","description":""},{"name":"Or.intro_left","description":""},{"name":"Or.intro_right","description":""},{"name":"Or.elim","description":""},{"name":"Bool","description":""},{"name":"Subtype","description":""},{"name":"optParam","description":"Gadget for optional parameter support. "},{"name":"outParam","description":"Gadget for marking output parameters in type classes. "},{"name":"typedExpr","description":"Auxiliary Declaration used to implement the notation (a : Œ±) "},{"name":"namedPattern","description":"Auxiliary Declaration used to implement the named patterns `x@h:p` "},{"name":"sorryAx","description":""},{"name":"eq_false_of_ne_true","description":""},{"name":"eq_true_of_ne_false","description":""},{"name":"ne_false_of_eq_true","description":""},{"name":"ne_true_of_eq_false","description":""},{"name":"Inhabited","description":""},{"name":"Nonempty","description":""},{"name":"Classical.choice","description":""},{"name":"Nonempty.elim","description":""},{"name":"instNonempty","description":""},{"name":"Classical.ofNonempty","description":""},{"name":"instNonemptyForAll","description":""},{"name":"instNonemptyForAll_1","description":""},{"name":"instInhabitedSort","description":""},{"name":"instInhabitedForAll","description":""},{"name":"instInhabitedForAll_1","description":""},{"name":"instInhabitedBool","description":""},{"name":"PLift","description":"Universe lifting operation from Sort to Type "},{"name":"PLift.up_down","description":""},{"name":"PLift.down_up","description":""},{"name":"NonemptyType","description":""},{"name":"NonemptyType.type","description":""},{"name":"instInhabitedNonemptyType","description":""},{"name":"ULift","description":"Universe lifting operation "},{"name":"ULift.up_down","description":""},{"name":"ULift.down_up","description":""},{"name":"Decidable","description":""},{"name":"Decidable.decide","description":""},{"name":"DecidablePred","description":""},{"name":"DecidableRel","description":""},{"name":"DecidableEq","description":""},{"name":"decEq","description":""},{"name":"decide_eq_true","description":""},{"name":"decide_eq_false","description":""},{"name":"of_decide_eq_true","description":""},{"name":"of_decide_eq_false","description":""},{"name":"of_decide_eq_self_eq_true","description":""},{"name":"instDecidableEqBool","description":""},{"name":"BEq","description":""},{"name":"instBEq","description":""},{"name":"dite","description":""},{"name":"ite","description":""},{"name":"instDecidableAnd","description":""},{"name":"instDecidableOr","description":""},{"name":"instDecidableNot","description":""},{"name":"cond","description":""},{"name":"or","description":""},{"name":"and","description":""},{"name":"not","description":""},{"name":"Nat","description":""},{"name":"instInhabitedNat","description":""},{"name":"OfNat","description":""},{"name":"instOfNatNat","description":""},{"name":"LE","description":""},{"name":"LT","description":""},{"name":"GE.ge","description":""},{"name":"GT.gt","description":""},{"name":"max","description":""},{"name":"min","description":""},{"name":"Trans","description":"Transitive chaining of proofs, used e.g. by `calc`. "},{"name":"instTransEq","description":""},{"name":"instTransEq_1","description":""},{"name":"HAdd","description":""},{"name":"HSub","description":""},{"name":"HMul","description":""},{"name":"HDiv","description":""},{"name":"HMod","description":""},{"name":"HPow","description":""},{"name":"HAppend","description":""},{"name":"HOrElse","description":""},{"name":"HAndThen","description":""},{"name":"HAnd","description":""},{"name":"HXor","description":""},{"name":"HOr","description":""},{"name":"HShiftLeft","description":""},{"name":"HShiftRight","description":""},{"name":"Add","description":""},{"name":"Sub","description":""},{"name":"Mul","description":""},{"name":"Neg","description":""},{"name":"Div","description":""},{"name":"Mod","description":""},{"name":"Pow","description":""},{"name":"Append","description":""},{"name":"OrElse","description":""},{"name":"AndThen","description":""},{"name":"AndOp","description":""},{"name":"Xor","description":""},{"name":"OrOp","description":""},{"name":"Complement","description":""},{"name":"ShiftLeft","description":""},{"name":"ShiftRight","description":""},{"name":"instHAdd","description":""},{"name":"instHSub","description":""},{"name":"instHMul","description":""},{"name":"instHDiv","description":""},{"name":"instHMod","description":""},{"name":"instHPow","description":""},{"name":"instHAppend","description":""},{"name":"instHOrElse","description":""},{"name":"instHAndThen","description":""},{"name":"instHAnd","description":""},{"name":"instHXor","description":""},{"name":"instHOr","description":""},{"name":"instHShiftLeft","description":""},{"name":"instHShiftRight","description":""},{"name":"Membership","description":""},{"name":"Nat.add","description":""},{"name":"instAddNat","description":""},{"name":"Nat.mul","description":""},{"name":"instMulNat","description":""},{"name":"Nat.pow","description":""},{"name":"instPowNat","description":""},{"name":"Nat.beq","description":""},{"name":"instBEqNat","description":""},{"name":"Nat.eq_of_beq_eq_true","description":""},{"name":"Nat.ne_of_beq_eq_false","description":""},{"name":"Nat.decEq","description":""},{"name":"instDecidableEqNat","description":""},{"name":"Nat.ble","description":""},{"name":"Nat.le","description":""},{"name":"instLENat","description":""},{"name":"Nat.lt","description":""},{"name":"instLTNat","description":""},{"name":"Nat.not_succ_le_zero","description":""},{"name":"Nat.not_lt_zero","description":""},{"name":"Nat.zero_le","description":""},{"name":"Nat.succ_le_succ","description":""},{"name":"Nat.zero_lt_succ","description":""},{"name":"Nat.le_step","description":""},{"name":"Nat.le_trans","description":""},{"name":"Nat.lt_trans","description":""},{"name":"Nat.le_succ","description":""},{"name":"Nat.le_succ_of_le","description":""},{"name":"Nat.le_refl","description":""},{"name":"Nat.succ_pos","description":""},{"name":"Nat.pred","description":""},{"name":"Nat.pred_le_pred","description":""},{"name":"Nat.le_of_succ_le_succ","description":""},{"name":"Nat.le_of_lt_succ","description":""},{"name":"Nat.eq_or_lt_of_le","description":""},{"name":"Nat.lt_or_ge","description":""},{"name":"Nat.not_succ_le_self","description":""},{"name":"Nat.lt_irrefl","description":""},{"name":"Nat.lt_of_le_of_lt","description":""},{"name":"Nat.le_antisymm","description":""},{"name":"Nat.lt_of_le_of_ne","description":""},{"name":"Nat.le_of_ble_eq_true","description":""},{"name":"Nat.ble_self_eq_true","description":""},{"name":"Nat.ble_succ_eq_true","description":""},{"name":"Nat.ble_eq_true_of_le","description":""},{"name":"Nat.not_le_of_not_ble_eq_true","description":""},{"name":"Nat.decLe","description":""},{"name":"Nat.decLt","description":""},{"name":"Nat.sub","description":""},{"name":"instSubNat","description":""},{"name":"System.Platform.getNumBits","description":""},{"name":"System.Platform.numBits","description":""},{"name":"System.Platform.numBits_eq","description":""},{"name":"Fin","description":""},{"name":"Fin.eq_of_val_eq","description":""},{"name":"Fin.val_eq_of_eq","description":""},{"name":"Fin.ne_of_val_ne","description":""},{"name":"instDecidableEqFin","description":""},{"name":"instLTFin","description":""},{"name":"instLEFin","description":""},{"name":"Fin.decLt","description":""},{"name":"Fin.decLe","description":""},{"name":"UInt8.size","description":""},{"name":"UInt8","description":""},{"name":"UInt8.ofNatCore","description":""},{"name":"UInt8.decEq","description":""},{"name":"instDecidableEqUInt8","description":""},{"name":"instInhabitedUInt8","description":""},{"name":"UInt16.size","description":""},{"name":"UInt16","description":""},{"name":"UInt16.ofNatCore","description":""},{"name":"UInt16.decEq","description":""},{"name":"instDecidableEqUInt16","description":""},{"name":"instInhabitedUInt16","description":""},{"name":"UInt32.size","description":""},{"name":"UInt32","description":""},{"name":"UInt32.ofNatCore","description":""},{"name":"UInt32.toNat","description":""},{"name":"UInt32.decEq","description":""},{"name":"instDecidableEqUInt32","description":""},{"name":"instInhabitedUInt32","description":""},{"name":"instLTUInt32","description":""},{"name":"instLEUInt32","description":""},{"name":"UInt32.decLt","description":""},{"name":"UInt32.decLe","description":""},{"name":"instDecidableLtUInt32InstLTUInt32","description":""},{"name":"instDecidableLeUInt32InstLEUInt32","description":""},{"name":"UInt64.size","description":""},{"name":"UInt64","description":""},{"name":"UInt64.ofNatCore","description":""},{"name":"UInt64.decEq","description":""},{"name":"instDecidableEqUInt64","description":""},{"name":"instInhabitedUInt64","description":""},{"name":"USize.size","description":""},{"name":"usize_size_eq","description":""},{"name":"USize","description":""},{"name":"USize.ofNatCore","description":""},{"name":"USize.decEq","description":""},{"name":"instDecidableEqUSize","description":""},{"name":"instInhabitedUSize","description":""},{"name":"USize.ofNat32","description":""},{"name":"Nat.isValidChar","description":""},{"name":"UInt32.isValidChar","description":""},{"name":"Char","description":"The `Char` Type represents an unicode scalar value.\n    See http://www.unicode.org/glossary/#unicode_scalar_value). "},{"name":"Char.ofNatAux","description":""},{"name":"Char.ofNat","description":""},{"name":"Char.eq_of_val_eq","description":""},{"name":"Char.val_eq_of_eq","description":""},{"name":"Char.ne_of_val_ne","description":""},{"name":"Char.val_ne_of_ne","description":""},{"name":"instDecidableEqChar","description":""},{"name":"Char.utf8Size","description":""},{"name":"Option","description":""},{"name":"instInhabitedOption","description":""},{"name":"Option.getD","description":""},{"name":"List","description":""},{"name":"instInhabitedList","description":""},{"name":"List.hasDecEq","description":""},{"name":"instDecidableEqList","description":""},{"name":"List.foldl","description":""},{"name":"List.set","description":""},{"name":"List.length","description":""},{"name":"List.lengthTRAux","description":""},{"name":"List.lengthTR","description":""},{"name":"List.length_cons","description":""},{"name":"List.concat","description":""},{"name":"List.get","description":""},{"name":"String","description":""},{"name":"String.decEq","description":""},{"name":"instDecidableEqString","description":""},{"name":"String.Pos","description":"A byte position in a `String`. Internally, `String`s are UTF-8 encoded.\nCodepoint positions (counting the Unicode codepoints rather than bytes)\nare represented by plain `Nat`s instead.\nIndexing a `String` by a byte position is constant-time, while codepoint\npositions need to be translated internally to byte positions in linear-time. "},{"name":"instInhabitedPos","description":""},{"name":"instDecidableEqPos","description":""},{"name":"Substring","description":""},{"name":"instInhabitedSubstring","description":""},{"name":"Substring.bsize","description":""},{"name":"String.csize","description":""},{"name":"String.utf8ByteSize","description":""},{"name":"String.utf8ByteSize.go","description":""},{"name":"instHAddPos","description":""},{"name":"instHSubPos","description":""},{"name":"instHAddPosChar","description":""},{"name":"instHAddPosString","description":""},{"name":"instLEPos","description":""},{"name":"instLTPos","description":""},{"name":"instDecidableLePosInstLEPos","description":""},{"name":"instDecidableLtPosInstLTPos","description":""},{"name":"String.endPos","description":""},{"name":"String.toSubstring","description":""},{"name":"unsafeCast","description":""},{"name":"panicCore","description":""},{"name":"panic","description":""},{"name":"Array","description":""},{"name":"Array.mkEmpty","description":""},{"name":"Array.empty","description":""},{"name":"Array.size","description":""},{"name":"Array.get","description":""},{"name":"Array.getD","description":""},{"name":"Array.get!","description":""},{"name":"Array.getOp","description":""},{"name":"Array.push","description":""},{"name":"Array.set","description":""},{"name":"Array.setD","description":""},{"name":"Array.set!","description":""},{"name":"Array.appendCore","description":""},{"name":"Array.appendCore.loop","description":""},{"name":"List.toArrayAux","description":""},{"name":"List.redLength","description":""},{"name":"List.toArray","description":""},{"name":"Bind","description":""},{"name":"Pure","description":""},{"name":"Functor","description":""},{"name":"Seq","description":""},{"name":"SeqLeft","description":""},{"name":"SeqRight","description":""},{"name":"Applicative","description":""},{"name":"Monad","description":""},{"name":"instInhabitedForAll_2","description":""},{"name":"instInhabited","description":""},{"name":"Array.sequenceMap","description":""},{"name":"Array.sequenceMap.loop","description":""},{"name":"MonadLift","description":"A Function for lifting a computation from an inner Monad to an outer Monad.\n    Like [MonadTrans](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html),\n    but `n` does not have to be a monad transformer.\n    Alternatively, an implementation of [MonadLayer](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer) without `layerInvmap` (so far). "},{"name":"MonadLiftT","description":"The reflexive-transitive closure of `MonadLift`.\n    `monadLift` is used to transitively lift monadic computations such as `StateT.get` or `StateT.put s`.\n    Corresponds to [MonadLift](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift). "},{"name":"liftM","description":""},{"name":"instMonadLiftT","description":""},{"name":"instMonadLiftT_1","description":""},{"name":"MonadFunctor","description":"A functor in the category of monads. Can be used to lift monad-transforming functions.\n    Based on pipes' [MFunctor](https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html),\n    but not restricted to monad transformers.\n    Alternatively, an implementation of [MonadTransFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor). "},{"name":"MonadFunctorT","description":"The reflexive-transitive closure of `MonadFunctor`.\n    `monadMap` is used to transitively lift Monad morphisms "},{"name":"instMonadFunctorT","description":""},{"name":"monadFunctorRefl","description":""},{"name":"Except","description":""},{"name":"instInhabitedExcept","description":""},{"name":"MonadExceptOf","description":"An implementation of [MonadError](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError) "},{"name":"throwThe","description":""},{"name":"tryCatchThe","description":""},{"name":"MonadExcept","description":"Similar to `MonadExceptOf`, but `Œµ` is an outParam for convenience "},{"name":"instMonadExcept","description":""},{"name":"MonadExcept.orElse","description":""},{"name":"MonadExcept.instOrElse","description":""},{"name":"ReaderT","description":"An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT) "},{"name":"instInhabitedReaderT","description":""},{"name":"ReaderT.run","description":""},{"name":"ReaderT.instMonadLiftReaderT","description":""},{"name":"ReaderT.instMonadExceptOfReaderT","description":""},{"name":"ReaderT.read","description":""},{"name":"ReaderT.pure","description":""},{"name":"ReaderT.bind","description":""},{"name":"ReaderT.map","description":""},{"name":"ReaderT.instMonadReaderT","description":""},{"name":"ReaderT.instMonadFunctorReaderT","description":""},{"name":"ReaderT.adapt","description":""},{"name":"MonadReaderOf","description":"An implementation of [MonadReader](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader).\n    It does not contain `local` because this Function cannot be lifted using `monadLift`.\n    Instead, the `MonadReaderAdapter` class provides the more general `adaptReader` Function.\n\n    Note: This class can be seen as a simplification of the more \"principled\" definition\n    ```\n    class MonadReader (œÅ : outParam (Type u)) (n : Type u ‚Üí Type u) where\n      lift {Œ± : Type u} : ({m : Type u ‚Üí Type u} ‚Üí [Monad m] ‚Üí ReaderT œÅ m Œ±) ‚Üí n Œ±\n    ```\n    "},{"name":"readThe","description":""},{"name":"MonadReader","description":"Similar to `MonadReaderOf`, but `œÅ` is an outParam for convenience "},{"name":"instMonadReader","description":""},{"name":"instMonadReaderOf","description":""},{"name":"instMonadReaderOfReaderT","description":""},{"name":"MonadWithReaderOf","description":""},{"name":"withTheReader","description":""},{"name":"MonadWithReader","description":""},{"name":"instMonadWithReader","description":""},{"name":"instMonadWithReaderOf","description":""},{"name":"instMonadWithReaderOfReaderT","description":""},{"name":"MonadStateOf","description":"An implementation of [MonadState](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html).\n    In contrast to the Haskell implementation, we use overlapping instances to derive instances\n    automatically from `monadLift`. "},{"name":"getThe","description":""},{"name":"modifyThe","description":""},{"name":"modifyGetThe","description":""},{"name":"MonadState","description":"Similar to `MonadStateOf`, but `œÉ` is an outParam for convenience "},{"name":"instMonadState","description":""},{"name":"modify","description":""},{"name":"getModify","description":""},{"name":"instMonadStateOf","description":""},{"name":"EStateM.Result","description":""},{"name":"EStateM.instInhabitedResult","description":""},{"name":"EStateM","description":""},{"name":"EStateM.instInhabitedEStateM","description":""},{"name":"EStateM.pure","description":""},{"name":"EStateM.set","description":""},{"name":"EStateM.get","description":""},{"name":"EStateM.modifyGet","description":""},{"name":"EStateM.throw","description":""},{"name":"EStateM.Backtrackable","description":"Auxiliary instance for saving/restoring the \"backtrackable\" part of the state. "},{"name":"EStateM.tryCatch","description":""},{"name":"EStateM.orElse","description":""},{"name":"EStateM.adaptExcept","description":""},{"name":"EStateM.bind","description":""},{"name":"EStateM.map","description":""},{"name":"EStateM.seqRight","description":""},{"name":"EStateM.instMonadEStateM","description":""},{"name":"EStateM.instOrElseEStateM","description":""},{"name":"EStateM.instMonadStateOfEStateM","description":""},{"name":"EStateM.instMonadExceptOfEStateM","description":""},{"name":"EStateM.run","description":""},{"name":"EStateM.run'","description":""},{"name":"EStateM.dummySave","description":""},{"name":"EStateM.dummyRestore","description":""},{"name":"EStateM.nonBacktrackable","description":""},{"name":"Hashable","description":""},{"name":"UInt64.toUSize","description":""},{"name":"USize.toUInt64","description":""},{"name":"mixHash","description":""},{"name":"String.hash","description":""},{"name":"instHashableString","description":""},{"name":"Lean.Name","description":""},{"name":"Lean.instInhabitedName","description":""},{"name":"Lean.Name.hash","description":""},{"name":"Lean.instHashableName","description":""},{"name":"Lean.Name.mkStr","description":""},{"name":"Lean.Name.mkNum","description":""},{"name":"Lean.Name.mkSimple","description":""},{"name":"Lean.Name.beq","description":""},{"name":"Lean.Name.instBEqName","description":""},{"name":"Lean.Name.append","description":""},{"name":"Lean.Name.instAppendName","description":""},{"name":"Lean.SourceInfo","description":"Source information of tokens. "},{"name":"Lean.instInhabitedSourceInfo","description":""},{"name":"Lean.SourceInfo.getPos?","description":""},{"name":"Lean.SyntaxNodeKind","description":""},{"name":"Lean.Syntax","description":"Syntax objects used by the parser, macro expander, delaborator, etc.\n"},{"name":"Lean.instInhabitedSyntax","description":""},{"name":"Lean.choiceKind","description":""},{"name":"Lean.nullKind","description":""},{"name":"Lean.groupKind","description":""},{"name":"Lean.identKind","description":""},{"name":"Lean.strLitKind","description":""},{"name":"Lean.charLitKind","description":""},{"name":"Lean.numLitKind","description":""},{"name":"Lean.scientificLitKind","description":""},{"name":"Lean.nameLitKind","description":""},{"name":"Lean.fieldIdxKind","description":""},{"name":"Lean.interpolatedStrLitKind","description":""},{"name":"Lean.interpolatedStrKind","description":""},{"name":"Lean.Syntax.getKind","description":""},{"name":"Lean.Syntax.setKind","description":""},{"name":"Lean.Syntax.isOfKind","description":""},{"name":"Lean.Syntax.getArg","description":""},{"name":"Lean.Syntax.getOp","description":""},{"name":"Lean.Syntax.getArgs","description":""},{"name":"Lean.Syntax.getNumArgs","description":""},{"name":"Lean.Syntax.isMissing","description":""},{"name":"Lean.Syntax.isNodeOf","description":""},{"name":"Lean.Syntax.isIdent","description":""},{"name":"Lean.Syntax.getId","description":""},{"name":"Lean.Syntax.setArgs","description":""},{"name":"Lean.Syntax.setArg","description":""},{"name":"Lean.Syntax.getHeadInfo?","description":"Retrieve the left-most node or leaf's info in the Syntax tree. "},{"name":"Lean.Syntax.getHeadInfo?.loop","description":""},{"name":"Lean.Syntax.getHeadInfo","description":"Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. "},{"name":"Lean.Syntax.getPos?","description":""},{"name":"Lean.Syntax.getTailPos?","description":""},{"name":"Lean.Syntax.getTailPos?.loop","description":""},{"name":"Lean.Syntax.SepArray","description":"An array of syntax elements interspersed with separators. Can be coerced to/from `Array Syntax` to automatically\n  remove/insert the separators. "},{"name":"Lean.SourceInfo.fromRef","description":""},{"name":"Lean.mkAtom","description":""},{"name":"Lean.mkAtomFrom","description":""},{"name":"Lean.ParserDescr","description":""},{"name":"Lean.instInhabitedParserDescr","description":""},{"name":"Lean.TrailingParserDescr","description":""},{"name":"Lean.MacroScope","description":""},{"name":"Lean.reservedMacroScope","description":"Macro scope used internally. It is not available for our frontend. "},{"name":"Lean.firstFrontendMacroScope","description":"First macro scope available for our frontend "},{"name":"Lean.MonadRef","description":""},{"name":"Lean.instMonadRef","description":""},{"name":"Lean.replaceRef","description":""},{"name":"Lean.withRef","description":""},{"name":"Lean.MonadQuotation","description":"A monad that supports syntax quotations. Syntax quotations (in term\n    position) are monadic values that when executed retrieve the current \"macro\n    scope\" from the monad and apply it to every identifier they introduce\n    (independent of whether this identifier turns out to be a reference to an\n    existing declaration, or an actually fresh binding during further\n    elaboration). We also apply the position of the result of `getRef` to each\n    introduced symbol, which results in better error positions than not applying\n    any position. "},{"name":"Lean.MonadRef.mkInfoFromRefPos","description":""},{"name":"Lean.instMonadQuotation","description":""},{"name":"Lean.Name.hasMacroScopes","description":""},{"name":"Lean.Name.eraseMacroScopes","description":""},{"name":"Lean.Name.simpMacroScopes","description":""},{"name":"Lean.MacroScopesView","description":""},{"name":"Lean.instInhabitedMacroScopesView","description":""},{"name":"Lean.MacroScopesView.review","description":""},{"name":"Lean.extractMacroScopes","description":"Revert all `addMacroScope` calls. `v = extractMacroScopes n ‚Üí n = v.review`.\n  This operation is useful for analyzing/transforming the original identifiers, then adding back\n  the scopes (via `MacroScopesView.review`). "},{"name":"Lean.addMacroScope","description":""},{"name":"Lean.MonadQuotation.addMacroScope","description":""},{"name":"Lean.defaultMaxRecDepth","description":""},{"name":"Lean.maxRecDepthErrorMessage","description":""},{"name":"Lean.Syntax.matchesNull","description":""},{"name":"Lean.Syntax.matchesIdent","description":"Function used for determining whether a syntax pattern `` `(id) `` is matched.\n  There are various conceivable notions of when two syntactic identifiers should be regarded as identical,\n  but semantic definitions like whether they refer to the same global name cannot be implemented without\n  context information (i.e. `MonadResolveName`). Thus in patterns we default to the structural solution\n  of comparing the identifiers' `Name` values, though we at least do so modulo macro scopes so that\n  identifiers that \"look\" the same match. This is particularly useful when dealing with identifiers that\n  do not actually refer to Lean bindings, e.g. in the `stx` pattern `` `(many($p)) ``. "},{"name":"Lean.Syntax.matchesLit","description":""},{"name":"Lean.Macro.instNonemptyMethodsRef","description":""},{"name":"Lean.Macro.Context","description":""},{"name":"Lean.Macro.Exception","description":""},{"name":"Lean.Macro.State","description":""},{"name":"Lean.Macro.instInhabitedState","description":""},{"name":"Lean.MacroM","description":""},{"name":"Lean.Macro","description":""},{"name":"Lean.Macro.instMonadRefMacroM","description":""},{"name":"Lean.Macro.addMacroScope","description":""},{"name":"Lean.Macro.throwUnsupported","description":""},{"name":"Lean.Macro.throwError","description":""},{"name":"Lean.Macro.throwErrorAt","description":""},{"name":"Lean.Macro.withFreshMacroScope","description":""},{"name":"Lean.Macro.withIncRecDepth","description":""},{"name":"Lean.Macro.instMonadQuotationMacroM","description":""},{"name":"Lean.Macro.Methods","description":""},{"name":"Lean.Macro.instInhabitedMethods","description":""},{"name":"Lean.Macro.mkMethodsImp","description":""},{"name":"Lean.Macro.mkMethods","description":""},{"name":"Lean.Macro.instInhabitedMethodsRef","description":""},{"name":"Lean.Macro.getMethodsImp","description":""},{"name":"Lean.Macro.getMethods","description":""},{"name":"Lean.Macro.expandMacro?","description":"`expandMacro? stx` return `some stxNew` if `stx` is a macro, and `stxNew` is its expansion. "},{"name":"Lean.Macro.hasDecl","description":"Return `true` if the environment contains a declaration with name `declName` "},{"name":"Lean.Macro.getCurrNamespace","description":""},{"name":"Lean.Macro.resolveNamespace?","description":""},{"name":"Lean.Macro.resolveGlobalName","description":""},{"name":"Lean.Macro.trace","description":""},{"name":"Lean.PrettyPrinter.UnexpandM","description":""},{"name":"Lean.PrettyPrinter.Unexpander","description":"Function that tries to reverse macro expansions as a post-processing step of delaboration.\n  While less general than an arbitrary delaborator, it can be declared without importing `Lean`.\n  Used by the `[appUnexpander]` attribute. "},{"name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","description":""},{"name":"Nat.log2","description":"Computes `‚åämax 0 (log‚ÇÇ n)‚åã`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n"},{"name":"ReaderT.orElse","description":""},{"name":"ReaderT.failure","description":""},{"name":"ReaderT.instAlternativeReaderT","description":""},{"name":"instMonadControlReaderT","description":""},{"name":"ReaderT.tryFinally","description":""},{"name":"Reader","description":""},{"name":"SizeOf","description":""},{"name":"default.sizeOf","description":""},{"name":"instSizeOf","description":""},{"name":"sizeOf_default","description":""},{"name":"instSizeOfNat","description":""},{"name":"sizeOf_nat","description":""},{"name":"instSizeOfForAllUnit","description":""},{"name":"sizeOf_thunk","description":""},{"name":"Unit.sizeOf","description":""},{"name":"Bool.sizeOf_eq_one","description":""},{"name":"Lean.Name.sizeOf","description":""},{"name":"Lean.instSizeOfName","description":""},{"name":"Lean.Name.anonymous.sizeOf_spec","description":""},{"name":"Lean.Name.str.sizeOf_spec","description":""},{"name":"Lean.Name.num.sizeOf_spec","description":""},{"name":"Nat.SOM.Expr","description":""},{"name":"Nat.SOM.instInhabitedExpr","description":""},{"name":"Nat.SOM.Expr.denote","description":""},{"name":"Nat.SOM.Mon","description":""},{"name":"Nat.SOM.Mon.denote","description":""},{"name":"Nat.SOM.Mon.mul","description":""},{"name":"Nat.SOM.Mon.mul.go","description":""},{"name":"Nat.SOM.Poly","description":""},{"name":"Nat.SOM.Poly.denote","description":""},{"name":"Nat.SOM.Poly.add","description":""},{"name":"Nat.SOM.Poly.add.go","description":""},{"name":"Nat.SOM.Poly.insertSorted","description":""},{"name":"Nat.SOM.Poly.mulMon","description":""},{"name":"Nat.SOM.Poly.mulMon.go","description":""},{"name":"Nat.SOM.Poly.mul","description":""},{"name":"Nat.SOM.Poly.mul.go","description":""},{"name":"Nat.SOM.Expr.toPoly","description":""},{"name":"Nat.SOM.Mon.append_denote","description":""},{"name":"Nat.SOM.Mon.mul_denote","description":""},{"name":"Nat.SOM.Mon.mul_denote.go","description":""},{"name":"Nat.SOM.Poly.append_denote","description":""},{"name":"Nat.SOM.Poly.add_denote","description":""},{"name":"Nat.SOM.Poly.add_denote.go","description":""},{"name":"Nat.SOM.Poly.denote_insertSorted","description":""},{"name":"Nat.SOM.Poly.mulMon_denote","description":""},{"name":"Nat.SOM.Poly.mulMon_denote.go","description":""},{"name":"Nat.SOM.Poly.mul_denote","description":""},{"name":"Nat.SOM.Poly.mul_denote.go","description":""},{"name":"Nat.SOM.Expr.toPoly_denote","description":""},{"name":"Nat.SOM.Expr.eq_of_toPoly_eq","description":""},{"name":"monadLift_self","description":""},{"name":"LawfulFunctor","description":""},{"name":"id_map'","description":""},{"name":"LawfulApplicative","description":""},{"name":"pure_id_seq","description":""},{"name":"LawfulMonad","description":""},{"name":"bind_pure","description":""},{"name":"map_eq_pure_bind","description":""},{"name":"seq_eq_bind_map","description":""},{"name":"bind_congr","description":""},{"name":"bind_pure_unit","description":""},{"name":"map_congr","description":""},{"name":"seq_eq_bind","description":""},{"name":"seqRight_eq_bind","description":""},{"name":"seqLeft_eq_bind","description":""},{"name":"Id.map_eq","description":""},{"name":"Id.bind_eq","description":""},{"name":"Id.pure_eq","description":""},{"name":"Id.instLawfulMonadIdInstMonadId","description":""},{"name":"ExceptT.ext","description":""},{"name":"ExceptT.run_pure","description":""},{"name":"ExceptT.run_lift","description":""},{"name":"ExceptT.run_throw","description":""},{"name":"ExceptT.run_bind_lift","description":""},{"name":"ExceptT.bind_throw","description":""},{"name":"ExceptT.run_bind","description":""},{"name":"ExceptT.lift_pure","description":""},{"name":"ExceptT.run_map","description":""},{"name":"ExceptT.seq_eq","description":""},{"name":"ExceptT.bind_pure_comp","description":""},{"name":"ExceptT.seqLeft_eq","description":""},{"name":"ExceptT.seqRight_eq","description":""},{"name":"ExceptT.instLawfulMonadExceptTInstMonadExceptT","description":""},{"name":"ReaderT.ext","description":""},{"name":"ReaderT.run_pure","description":""},{"name":"ReaderT.run_bind","description":""},{"name":"ReaderT.run_map","description":""},{"name":"ReaderT.run_monadLift","description":""},{"name":"ReaderT.run_monadMap","description":""},{"name":"ReaderT.run_read","description":""},{"name":"ReaderT.run_seq","description":""},{"name":"ReaderT.run_seqRight","description":""},{"name":"ReaderT.run_seqLeft","description":""},{"name":"ReaderT.instLawfulMonadReaderTInstMonadReaderT","description":""},{"name":"instLawfulMonadStateRefT'InstMonadStateRefT'","description":""},{"name":"StateT.ext","description":""},{"name":"StateT.run'_eq","description":""},{"name":"StateT.run_pure","description":""},{"name":"StateT.run_bind","description":""},{"name":"StateT.run_map","description":""},{"name":"StateT.run_get","description":""},{"name":"StateT.run_set","description":""},{"name":"StateT.run_modify","description":""},{"name":"StateT.run_modifyGet","description":""},{"name":"StateT.run_lift","description":""},{"name":"StateT.run_bind_lift","description":""},{"name":"StateT.run_monadLift","description":""},{"name":"StateT.run_monadMap","description":""},{"name":"StateT.run_seq","description":""},{"name":"StateT.run_seqRight","description":""},{"name":"StateT.run_seqLeft","description":""},{"name":"StateT.seqRight_eq","description":""},{"name":"StateT.seqLeft_eq","description":""},{"name":"StateT.instLawfulMonadStateTInstMonadStateT","description":""},{"name":"Option.toMonad","description":""},{"name":"Option.toBool","description":""},{"name":"Option.isSome","description":""},{"name":"Option.isNone","description":""},{"name":"Option.isEqSome","description":""},{"name":"Option.bind","description":""},{"name":"Option.map","description":""},{"name":"Option.mapM","description":""},{"name":"Option.map_id","description":""},{"name":"Option.instFunctorOption","description":""},{"name":"Option.filter","description":""},{"name":"Option.all","description":""},{"name":"Option.any","description":""},{"name":"Option.orElse","description":""},{"name":"Option.instOrElseOption","description":""},{"name":"Option.lt","description":""},{"name":"Option.instDecidableRelOptionLt","description":""},{"name":"instDecidableEqOption","description":""},{"name":"instBEqOption","description":""},{"name":"instLTOption","description":""},{"name":"instFunctorOption","description":""},{"name":"instMonadOption","description":""},{"name":"instAlternativeOption","description":""},{"name":"liftOption","description":""},{"name":"Option.tryCatch","description":""},{"name":"instMonadExceptOfUnitOption","description":""},{"name":"List.get!","description":""},{"name":"List.get?","description":""},{"name":"List.getD","description":""},{"name":"List.head!","description":""},{"name":"List.head?","description":""},{"name":"List.headD","description":""},{"name":"List.head","description":""},{"name":"List.tail!","description":""},{"name":"List.tail?","description":""},{"name":"List.tailD","description":""},{"name":"List.getLast","description":""},{"name":"List.getLast!","description":""},{"name":"List.getLast?","description":""},{"name":"List.getLastD","description":""},{"name":"List.rotateLeft","description":""},{"name":"List.rotateRight","description":""},{"name":"List.get_append_left","description":""},{"name":"List.get_append_right","description":""},{"name":"List.get_last","description":""},{"name":"List.sizeOf_lt_of_mem","description":""},{"name":"List.tacticSizeOf_list_dec","description":""},{"name":"List.append_cancel_left","description":""},{"name":"List.append_cancel_right","description":""},{"name":"List.append_cancel_left_eq","description":""},{"name":"List.append_cancel_right_eq","description":""},{"name":"List.sizeOf_get","description":""},{"name":"List.le_antisymm","description":""},{"name":"List.instAntisymmListLeInstLEList","description":""},{"name":"UInt8.ofNat","description":""},{"name":"Nat.toUInt8","description":""},{"name":"UInt8.toNat","description":""},{"name":"UInt8.add","description":""},{"name":"UInt8.sub","description":""},{"name":"UInt8.mul","description":""},{"name":"UInt8.div","description":""},{"name":"UInt8.mod","description":""},{"name":"UInt8.modn","description":""},{"name":"UInt8.land","description":""},{"name":"UInt8.lor","description":""},{"name":"UInt8.xor","description":""},{"name":"UInt8.shiftLeft","description":""},{"name":"UInt8.shiftRight","description":""},{"name":"UInt8.lt","description":""},{"name":"UInt8.le","description":""},{"name":"instOfNatUInt8","description":""},{"name":"instAddUInt8","description":""},{"name":"instSubUInt8","description":""},{"name":"instMulUInt8","description":""},{"name":"instModUInt8","description":""},{"name":"instHModUInt8Nat","description":""},{"name":"instDivUInt8","description":""},{"name":"instLTUInt8","description":""},{"name":"instLEUInt8","description":""},{"name":"UInt8.complement","description":""},{"name":"instComplementUInt8","description":""},{"name":"instAndOpUInt8","description":""},{"name":"instOrOpUInt8","description":""},{"name":"instXorUInt8","description":""},{"name":"instShiftLeftUInt8","description":""},{"name":"instShiftRightUInt8","description":""},{"name":"UInt8.decLt","description":""},{"name":"UInt8.decLe","description":""},{"name":"instDecidableLtUInt8InstLTUInt8","description":""},{"name":"instDecidableLeUInt8InstLEUInt8","description":""},{"name":"UInt16.ofNat","description":""},{"name":"Nat.toUInt16","description":""},{"name":"UInt16.toNat","description":""},{"name":"UInt16.add","description":""},{"name":"UInt16.sub","description":""},{"name":"UInt16.mul","description":""},{"name":"UInt16.div","description":""},{"name":"UInt16.mod","description":""},{"name":"UInt16.modn","description":""},{"name":"UInt16.land","description":""},{"name":"UInt16.lor","description":""},{"name":"UInt16.xor","description":""},{"name":"UInt16.shiftLeft","description":""},{"name":"UInt16.toUInt8","description":""},{"name":"UInt8.toUInt16","description":""},{"name":"UInt16.shiftRight","description":""},{"name":"UInt16.lt","description":""},{"name":"UInt16.le","description":""},{"name":"instOfNatUInt16","description":""},{"name":"instAddUInt16","description":""},{"name":"instSubUInt16","description":""},{"name":"instMulUInt16","description":""},{"name":"instModUInt16","description":""},{"name":"instHModUInt16Nat","description":""},{"name":"instDivUInt16","description":""},{"name":"instLTUInt16","description":""},{"name":"instLEUInt16","description":""},{"name":"UInt16.complement","description":""},{"name":"instComplementUInt16","description":""},{"name":"instAndOpUInt16","description":""},{"name":"instOrOpUInt16","description":""},{"name":"instXorUInt16","description":""},{"name":"instShiftLeftUInt16","description":""},{"name":"instShiftRightUInt16","description":""},{"name":"UInt16.decLt","description":""},{"name":"UInt16.decLe","description":""},{"name":"instDecidableLtUInt16InstLTUInt16","description":""},{"name":"instDecidableLeUInt16InstLEUInt16","description":""},{"name":"UInt32.ofNat","description":""},{"name":"UInt32.ofNat'","description":""},{"name":"Nat.toUInt32","description":""},{"name":"UInt32.add","description":""},{"name":"UInt32.sub","description":""},{"name":"UInt32.mul","description":""},{"name":"UInt32.div","description":""},{"name":"UInt32.mod","description":""},{"name":"UInt32.modn","description":""},{"name":"UInt32.land","description":""},{"name":"UInt32.lor","description":""},{"name":"UInt32.xor","description":""},{"name":"UInt32.shiftLeft","description":""},{"name":"UInt32.shiftRight","description":""},{"name":"UInt32.toUInt8","description":""},{"name":"UInt32.toUInt16","description":""},{"name":"UInt8.toUInt32","description":""},{"name":"UInt16.toUInt32","description":""},{"name":"instOfNatUInt32","description":""},{"name":"instAddUInt32","description":""},{"name":"instSubUInt32","description":""},{"name":"instMulUInt32","description":""},{"name":"instModUInt32","description":""},{"name":"instHModUInt32Nat","description":""},{"name":"instDivUInt32","description":""},{"name":"UInt32.complement","description":""},{"name":"instComplementUInt32","description":""},{"name":"instAndOpUInt32","description":""},{"name":"instOrOpUInt32","description":""},{"name":"instXorUInt32","description":""},{"name":"instShiftLeftUInt32","description":""},{"name":"instShiftRightUInt32","description":""},{"name":"UInt64.ofNat","description":""},{"name":"Nat.toUInt64","description":""},{"name":"UInt64.toNat","description":""},{"name":"UInt64.add","description":""},{"name":"UInt64.sub","description":""},{"name":"UInt64.mul","description":""},{"name":"UInt64.div","description":""},{"name":"UInt64.mod","description":""},{"name":"UInt64.modn","description":""},{"name":"UInt64.land","description":""},{"name":"UInt64.lor","description":""},{"name":"UInt64.xor","description":""},{"name":"UInt64.shiftLeft","description":""},{"name":"UInt64.shiftRight","description":""},{"name":"UInt64.lt","description":""},{"name":"UInt64.le","description":""},{"name":"UInt64.toUInt8","description":""},{"name":"UInt64.toUInt16","description":""},{"name":"UInt64.toUInt32","description":""},{"name":"UInt8.toUInt64","description":""},{"name":"UInt16.toUInt64","description":""},{"name":"UInt32.toUInt64","description":""},{"name":"instOfNatUInt64","description":""},{"name":"instAddUInt64","description":""},{"name":"instSubUInt64","description":""},{"name":"instMulUInt64","description":""},{"name":"instModUInt64","description":""},{"name":"instHModUInt64Nat","description":""},{"name":"instDivUInt64","description":""},{"name":"instLTUInt64","description":""},{"name":"instLEUInt64","description":""},{"name":"UInt64.complement","description":""},{"name":"instComplementUInt64","description":""},{"name":"instAndOpUInt64","description":""},{"name":"instOrOpUInt64","description":""},{"name":"instXorUInt64","description":""},{"name":"instShiftLeftUInt64","description":""},{"name":"instShiftRightUInt64","description":""},{"name":"Bool.toUInt64","description":""},{"name":"UInt64.decLt","description":""},{"name":"UInt64.decLe","description":""},{"name":"instDecidableLtUInt64InstLTUInt64","description":""},{"name":"instDecidableLeUInt64InstLEUInt64","description":""},{"name":"usize_size_gt_zero","description":""},{"name":"USize.ofNat","description":""},{"name":"Nat.toUSize","description":""},{"name":"USize.toNat","description":""},{"name":"USize.add","description":""},{"name":"USize.sub","description":""},{"name":"USize.mul","description":""},{"name":"USize.div","description":""},{"name":"USize.mod","description":""},{"name":"USize.modn","description":""},{"name":"USize.land","description":""},{"name":"USize.lor","description":""},{"name":"USize.xor","description":""},{"name":"USize.shiftLeft","description":""},{"name":"USize.shiftRight","description":""},{"name":"UInt32.toUSize","description":""},{"name":"USize.toUInt32","description":""},{"name":"USize.lt","description":""},{"name":"USize.le","description":""},{"name":"instOfNatUSize","description":""},{"name":"instAddUSize","description":""},{"name":"instSubUSize","description":""},{"name":"instMulUSize","description":""},{"name":"instModUSize","description":""},{"name":"instHModUSizeNat","description":""},{"name":"instDivUSize","description":""},{"name":"instLTUSize","description":""},{"name":"instLEUSize","description":""},{"name":"USize.complement","description":""},{"name":"instComplementUSize","description":""},{"name":"instAndOpUSize","description":""},{"name":"instOrOpUSize","description":""},{"name":"instXorUSize","description":""},{"name":"instShiftLeftUSize","description":""},{"name":"instShiftRightUSize","description":""},{"name":"USize.decLt","description":""},{"name":"USize.decLe","description":""},{"name":"instDecidableLtUSizeInstLTUSize","description":""},{"name":"instDecidableLeUSizeInstLEUSize","description":""},{"name":"USize.modn_lt","description":""},{"name":"Nat.bitwise_rec_lemma","description":""},{"name":"Nat.bitwise","description":""},{"name":"Nat.land","description":""},{"name":"Nat.lor","description":""},{"name":"Nat.xor","description":""},{"name":"Nat.shiftLeft","description":""},{"name":"Nat.shiftRight","description":""},{"name":"Nat.instAndOpNat","description":""},{"name":"Nat.instOrOpNat","description":""},{"name":"Nat.instXorNat","description":""},{"name":"Nat.instShiftLeftNat","description":""},{"name":"Nat.instShiftRightNat","description":""},{"name":"bfix1","description":""},{"name":"fixCore1","description":""},{"name":"fixCore","description":""},{"name":"fix1","description":""},{"name":"fix","description":""},{"name":"bfix2","description":""},{"name":"fixCore2","description":""},{"name":"fix2","description":""},{"name":"bfix3","description":""},{"name":"fixCore3","description":""},{"name":"fix3","description":""},{"name":"bfix4","description":""},{"name":"fixCore4","description":""},{"name":"fix4","description":""},{"name":"bfix5","description":""},{"name":"fixCore5","description":""},{"name":"fix5","description":""},{"name":"bfix6","description":""},{"name":"fixCore6","description":""},{"name":"fix6","description":""},{"name":"Socket.Socket.mk","description":"Create a new `Socket` using the specified domain and type.\n"},{"name":"Socket.Socket.close","description":"Close the `Socket`.\n\n  *NOTE:* Although Socket is designed to be automatically closed when garbage collected,\n  it's a good practice to manually close it beforehand.\n"},{"name":"Socket.Socket.connect","description":"Initiate a connection on a socket.\n"},{"name":"Socket.Socket.bind","description":"Bind a name to a socket.\n"},{"name":"Socket.Socket.listen","description":"Listen for connections on a socket.\n"},{"name":"Socket.Socket.accept","description":"Accept a connection on a socket.\n"},{"name":"Socket.Socket.send","description":"Send a message from a socket.\n"},{"name":"Socket.Socket.recv","description":"Receive a message from a socket.\n"},{"name":"Socket.Socket.sendto","description":"Send a message from a socket.\n"},{"name":"Socket.Socket.recvfrom","description":"Receive a message from a socket.\n"},{"name":"Socket.Socket.shutdown","description":"Shut down part of a full-duplex connection.\n"},{"name":"Socket.Socket.peer","description":"Get address of connected peer.\n"},{"name":"List.asString","description":""},{"name":"String.instOfNatPos","description":""},{"name":"String.instLTString","description":""},{"name":"String.decLt","description":""},{"name":"String.length","description":""},{"name":"String.push","description":"The internal implementation uses dynamic arrays and will perform destructive updates\n   if the String is not shared. "},{"name":"String.append","description":"The internal implementation uses dynamic arrays and will perform destructive updates\n   if the String is not shared. "},{"name":"String.toList","description":"O(n) in the runtime, where n is the length of the String "},{"name":"String.get","description":""},{"name":"String.getOp","description":""},{"name":"String.set","description":""},{"name":"String.modify","description":""},{"name":"String.next","description":""},{"name":"String.prev","description":""},{"name":"String.front","description":""},{"name":"String.back","description":""},{"name":"String.atEnd","description":""},{"name":"String.posOfAux","description":""},{"name":"String.posOf","description":""},{"name":"String.revPosOfAux","description":""},{"name":"String.revPosOf","description":""},{"name":"String.findAux","description":""},{"name":"String.find","description":""},{"name":"String.revFindAux","description":""},{"name":"String.revFind","description":""},{"name":"String.Pos.min","description":""},{"name":"String.firstDiffPos","description":"Returns the first position where the two strings differ. "},{"name":"String.firstDiffPos.loop","description":""},{"name":"String.extract","description":""},{"name":"String.extract.go‚ÇÅ","description":""},{"name":"String.extract.go‚ÇÇ","description":""},{"name":"String.splitAux","description":""},{"name":"String.split","description":""},{"name":"String.splitOnAux","description":""},{"name":"String.splitOn","description":""},{"name":"String.instInhabitedString","description":""},{"name":"String.instAppendString","description":""},{"name":"String.str","description":""},{"name":"String.pushn","description":""},{"name":"String.isEmpty","description":""},{"name":"String.join","description":""},{"name":"String.singleton","description":""},{"name":"String.intercalate","description":""},{"name":"String.intercalate.go","description":""},{"name":"String.Iterator","description":""},{"name":"String.instDecidableEqIterator","description":""},{"name":"String.mkIterator","description":""},{"name":"String.iter","description":""},{"name":"String.instSizeOfIterator","description":""},{"name":"String.Iterator.sizeOf_eq","description":""},{"name":"String.Iterator.toString","description":""},{"name":"String.Iterator.remainingBytes","description":""},{"name":"String.Iterator.pos","description":""},{"name":"String.Iterator.curr","description":""},{"name":"String.Iterator.next","description":""},{"name":"String.Iterator.prev","description":""},{"name":"String.Iterator.atEnd","description":""},{"name":"String.Iterator.hasNext","description":""},{"name":"String.Iterator.hasPrev","description":""},{"name":"String.Iterator.setCurr","description":""},{"name":"String.Iterator.toEnd","description":""},{"name":"String.Iterator.extract","description":""},{"name":"String.Iterator.forward","description":""},{"name":"String.Iterator.remainingToString","description":""},{"name":"String.Iterator.nextn","description":""},{"name":"String.Iterator.prevn","description":""},{"name":"String.offsetOfPosAux","description":""},{"name":"String.offsetOfPos","description":""},{"name":"String.foldlAux","description":""},{"name":"String.foldlAux.loop","description":""},{"name":"String.foldl","description":""},{"name":"String.foldrAux","description":""},{"name":"String.foldrAux.loop","description":""},{"name":"String.foldr","description":""},{"name":"String.anyAux","description":""},{"name":"String.anyAux.loop","description":""},{"name":"String.any","description":""},{"name":"String.all","description":""},{"name":"String.contains","description":""},{"name":"String.mapAux","description":""},{"name":"String.map","description":""},{"name":"String.isNat","description":""},{"name":"String.toNat?","description":""},{"name":"String.substrEq","description":"Return `true` iff the substring of byte size `sz` starting at position `off1` in `s1` is equal to that starting at `off2` in `s2.`.\nFalse if either substring of that byte size does not exist. "},{"name":"String.substrEq.loop","description":""},{"name":"String.isPrefixOf","description":"Return true iff `p` is a prefix of `s` "},{"name":"String.replace","description":"Replace all occurrences of `pattern` in `s` with `replacment`. "},{"name":"String.replace.loop","description":""},{"name":"Substring.isEmpty","description":""},{"name":"Substring.toString","description":""},{"name":"Substring.toIterator","description":""},{"name":"Substring.get","description":"Return the codepoint at the given offset into the substring. "},{"name":"Substring.next","description":"Given an offset of a codepoint into the substring,\nreturn the offset there of the next codepoint. "},{"name":"Substring.prev","description":"Given an offset of a codepoint into the substring,\nreturn the offset there of the previous codepoint. "},{"name":"Substring.nextn","description":""},{"name":"Substring.prevn","description":""},{"name":"Substring.front","description":""},{"name":"Substring.posOf","description":"Return the offset into `s` of the first occurence of `c` in `s`,\nor `s.bsize` if `c` doesn't occur. "},{"name":"Substring.drop","description":""},{"name":"Substring.dropRight","description":""},{"name":"Substring.take","description":""},{"name":"Substring.takeRight","description":""},{"name":"Substring.atEnd","description":""},{"name":"Substring.extract","description":""},{"name":"Substring.splitOn","description":""},{"name":"Substring.splitOn.loop","description":""},{"name":"Substring.foldl","description":""},{"name":"Substring.foldr","description":""},{"name":"Substring.any","description":""},{"name":"Substring.all","description":""},{"name":"Substring.contains","description":""},{"name":"Substring.takeWhile","description":""},{"name":"Substring.dropWhile","description":""},{"name":"Substring.takeRightWhile","description":""},{"name":"Substring.dropRightWhile","description":""},{"name":"Substring.trimLeft","description":""},{"name":"Substring.trimRight","description":""},{"name":"Substring.trim","description":""},{"name":"Substring.isNat","description":""},{"name":"Substring.toNat?","description":""},{"name":"Substring.beq","description":""},{"name":"Substring.hasBeq","description":""},{"name":"String.drop","description":""},{"name":"String.dropRight","description":""},{"name":"String.take","description":""},{"name":"String.takeRight","description":""},{"name":"String.takeWhile","description":""},{"name":"String.dropWhile","description":""},{"name":"String.takeRightWhile","description":""},{"name":"String.dropRightWhile","description":""},{"name":"String.startsWith","description":""},{"name":"String.endsWith","description":""},{"name":"String.trimRight","description":""},{"name":"String.trimLeft","description":""},{"name":"String.trim","description":""},{"name":"String.nextWhile","description":""},{"name":"String.nextUntil","description":""},{"name":"String.toUpper","description":""},{"name":"String.toLower","description":""},{"name":"String.capitalize","description":""},{"name":"String.decapitalize","description":""},{"name":"Char.toString","description":""},{"name":"Array.qpartition","description":""},{"name":"Array.qpartition.loop","description":""},{"name":"Array.qsort","description":""},{"name":"Array.qsort.sort","description":""},{"name":"Nat.gcd","description":""},{"name":"Nat.gcd_zero_left","description":""},{"name":"Nat.gcd_succ","description":""},{"name":"Nat.gcd_one_left","description":""},{"name":"Nat.gcd_zero_right","description":""},{"name":"Nat.gcd_self","description":""},{"name":"instHashableNat","description":""},{"name":"instHashablePos","description":""},{"name":"instHashableProd","description":""},{"name":"instHashableBool","description":""},{"name":"instHashableOption","description":""},{"name":"instHashableList","description":""},{"name":"instHashableArray","description":""},{"name":"instHashableUInt8","description":""},{"name":"instHashableUInt16","description":""},{"name":"instHashableUInt32","description":""},{"name":"instHashableUInt64","description":""},{"name":"instHashableUSize","description":""},{"name":"instHashableFin","description":""},{"name":"instHashableInt","description":""},{"name":"instHashable","description":""},{"name":"Nat.Linear.Var","description":"!\n  Helper definitions and theorems for constructing linear arithmetic proofs.\n"},{"name":"Nat.Linear.Context","description":""},{"name":"Nat.Linear.fixedVar","description":"When encoding polynomials. We use `fixedVar` for encoding numerals.\n  The denotation of `fixedVar` is always `1`. "},{"name":"Nat.Linear.Var.denote","description":""},{"name":"Nat.Linear.Var.denote.go","description":""},{"name":"Nat.Linear.Expr","description":""},{"name":"Nat.Linear.instInhabitedExpr","description":""},{"name":"Nat.Linear.Expr.denote","description":""},{"name":"Nat.Linear.Poly","description":""},{"name":"Nat.Linear.Poly.denote","description":""},{"name":"Nat.Linear.Poly.insertSorted","description":""},{"name":"Nat.Linear.Poly.sort","description":""},{"name":"Nat.Linear.Poly.sort.go","description":""},{"name":"Nat.Linear.Poly.fuse","description":""},{"name":"Nat.Linear.Poly.mul","description":""},{"name":"Nat.Linear.Poly.mul.go","description":""},{"name":"Nat.Linear.Poly.cancelAux","description":""},{"name":"Nat.Linear.hugeFuel","description":""},{"name":"Nat.Linear.Poly.cancel","description":""},{"name":"Nat.Linear.Poly.isNum?","description":""},{"name":"Nat.Linear.Poly.isZero","description":""},{"name":"Nat.Linear.Poly.isNonZero","description":""},{"name":"Nat.Linear.Poly.denote_eq","description":""},{"name":"Nat.Linear.Poly.denote_le","description":""},{"name":"Nat.Linear.Poly.combineAux","description":""},{"name":"Nat.Linear.Poly.combine","description":""},{"name":"Nat.Linear.Expr.toPoly","description":""},{"name":"Nat.Linear.Poly.norm","description":""},{"name":"Nat.Linear.Expr.toNormPoly","description":""},{"name":"Nat.Linear.Expr.inc","description":""},{"name":"Nat.Linear.PolyCnstr","description":""},{"name":"Nat.Linear.instBEqPolyCnstr","description":""},{"name":"Nat.Linear.instLawfulBEqPolyCnstrInstBEqPolyCnstr","description":""},{"name":"Nat.Linear.PolyCnstr.mul","description":""},{"name":"Nat.Linear.PolyCnstr.combine","description":""},{"name":"Nat.Linear.ExprCnstr","description":""},{"name":"Nat.Linear.PolyCnstr.denote","description":""},{"name":"Nat.Linear.PolyCnstr.norm","description":""},{"name":"Nat.Linear.PolyCnstr.isUnsat","description":""},{"name":"Nat.Linear.PolyCnstr.isValid","description":""},{"name":"Nat.Linear.ExprCnstr.denote","description":""},{"name":"Nat.Linear.ExprCnstr.toPoly","description":""},{"name":"Nat.Linear.ExprCnstr.toNormPoly","description":""},{"name":"Nat.Linear.Certificate","description":""},{"name":"Nat.Linear.Certificate.combineHyps","description":""},{"name":"Nat.Linear.Certificate.combine","description":""},{"name":"Nat.Linear.Certificate.denote","description":""},{"name":"Nat.Linear.monomialToExpr","description":""},{"name":"Nat.Linear.Poly.toExpr","description":""},{"name":"Nat.Linear.Poly.toExpr.go","description":""},{"name":"Nat.Linear.PolyCnstr.toExpr","description":""},{"name":"Nat.Linear.Poly.denote_insertSorted","description":""},{"name":"Nat.Linear.Poly.denote_sort_go","description":""},{"name":"Nat.Linear.Poly.denote_sort","description":""},{"name":"Nat.Linear.Poly.denote_append","description":""},{"name":"Nat.Linear.Poly.denote_cons","description":""},{"name":"Nat.Linear.Poly.denote_reverseAux","description":""},{"name":"Nat.Linear.Poly.denote_reverse","description":""},{"name":"Nat.Linear.Poly.denote_fuse","description":""},{"name":"Nat.Linear.Poly.denote_mul","description":""},{"name":"Nat.Linear.Poly.denote_eq_cancelAux","description":""},{"name":"Nat.Linear.Poly.of_denote_eq_cancelAux","description":""},{"name":"Nat.Linear.Poly.denote_eq_cancel","description":""},{"name":"Nat.Linear.Poly.of_denote_eq_cancel","description":""},{"name":"Nat.Linear.Poly.denote_eq_cancel_eq","description":""},{"name":"Nat.Linear.Poly.denote_le_cancelAux","description":""},{"name":"Nat.Linear.Poly.of_denote_le_cancelAux","description":""},{"name":"Nat.Linear.Poly.denote_le_cancel","description":""},{"name":"Nat.Linear.Poly.of_denote_le_cancel","description":""},{"name":"Nat.Linear.Poly.denote_le_cancel_eq","description":""},{"name":"Nat.Linear.Poly.denote_combineAux","description":""},{"name":"Nat.Linear.Poly.denote_combine","description":""},{"name":"Nat.Linear.Expr.denote_toPoly","description":""},{"name":"Nat.Linear.Expr.eq_of_toNormPoly","description":""},{"name":"Nat.Linear.Expr.of_cancel_eq","description":""},{"name":"Nat.Linear.Expr.of_cancel_le","description":""},{"name":"Nat.Linear.Expr.of_cancel_lt","description":""},{"name":"Nat.Linear.ExprCnstr.toPoly_norm_eq","description":""},{"name":"Nat.Linear.ExprCnstr.denote_toPoly","description":""},{"name":"Nat.Linear.ExprCnstr.denote_toNormPoly","description":""},{"name":"Nat.Linear.Poly.mul.go_denote","description":""},{"name":"Nat.Linear.PolyCnstr.denote_mul","description":""},{"name":"Nat.Linear.PolyCnstr.denote_combine","description":""},{"name":"Nat.Linear.Poly.isNum?_eq_some","description":""},{"name":"Nat.Linear.Poly.of_isZero","description":""},{"name":"Nat.Linear.Poly.of_isNonZero","description":""},{"name":"Nat.Linear.PolyCnstr.eq_false_of_isUnsat","description":""},{"name":"Nat.Linear.PolyCnstr.eq_true_of_isValid","description":""},{"name":"Nat.Linear.ExprCnstr.eq_false_of_isUnsat","description":""},{"name":"Nat.Linear.ExprCnstr.eq_true_of_isValid","description":""},{"name":"Nat.Linear.Certificate.of_combineHyps","description":""},{"name":"Nat.Linear.Certificate.of_combine","description":""},{"name":"Nat.Linear.Certificate.of_combine_isUnsat","description":""},{"name":"Nat.Linear.denote_monomialToExpr","description":""},{"name":"Nat.Linear.Poly.denote_toExpr_go","description":""},{"name":"Nat.Linear.Poly.denote_toExpr","description":""},{"name":"Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq","description":""},{"name":"Nat.Linear.Expr.eq_of_toNormPoly_eq","description":""},{"name":"tacticSimp_wf","description":""},{"name":"tacticDecreasing_trivial","description":""},{"name":"tacticDecreasing_with_","description":""},{"name":"tacticDecreasing_tactic","description":""},{"name":"instLawfulBEqProdInstBEqProd","description":""},{"name":"List.length_add_eq_lengthTRAux","description":""},{"name":"List.length_eq_lengthTR","description":""},{"name":"List.length_nil","description":""},{"name":"List.reverseAux","description":""},{"name":"List.reverse","description":""},{"name":"List.reverseAux_reverseAux_nil","description":""},{"name":"List.reverseAux_reverseAux","description":""},{"name":"List.reverse_reverse","description":""},{"name":"List.append","description":""},{"name":"List.appendTR","description":""},{"name":"List.append_eq_appendTR","description":""},{"name":"List.instAppendList","description":""},{"name":"List.nil_append","description":""},{"name":"List.append_nil","description":""},{"name":"List.cons_append","description":""},{"name":"List.List.append_eq","description":""},{"name":"List.append_assoc","description":""},{"name":"List.append_cons","description":""},{"name":"List.instEmptyCollectionList","description":""},{"name":"List.erase","description":""},{"name":"List.eraseIdx","description":""},{"name":"List.isEmpty","description":""},{"name":"List.map","description":""},{"name":"List.mapTRAux","description":""},{"name":"List.mapTR","description":""},{"name":"List.reverseAux_eq_append","description":""},{"name":"List.reverse_nil","description":""},{"name":"List.reverse_cons","description":""},{"name":"List.reverse_append","description":""},{"name":"List.mapTRAux_eq","description":""},{"name":"List.map_eq_mapTR","description":""},{"name":"List.map‚ÇÇ","description":""},{"name":"List.join","description":""},{"name":"List.filterMap","description":""},{"name":"List.filterAux","description":""},{"name":"List.filter","description":""},{"name":"List.partitionAux","description":""},{"name":"List.partition","description":""},{"name":"List.dropWhile","description":""},{"name":"List.find?","description":""},{"name":"List.findSome?","description":""},{"name":"List.replace","description":""},{"name":"List.elem","description":""},{"name":"List.notElem","description":""},{"name":"List.contains","description":""},{"name":"List.Mem","description":""},{"name":"List.instMembershipList","description":""},{"name":"List.mem_of_elem_eq_true","description":""},{"name":"List.elem_eq_true_of_mem","description":""},{"name":"List.instDecidableMemListInstMembershipList","description":""},{"name":"List.mem_append_of_mem_left","description":""},{"name":"List.mem_append_of_mem_right","description":""},{"name":"List.eraseDupsAux","description":""},{"name":"List.eraseDups","description":""},{"name":"List.eraseRepsAux","description":""},{"name":"List.eraseReps","description":"Erase repeated adjacent elements. "},{"name":"List.spanAux","description":""},{"name":"List.span","description":""},{"name":"List.groupByAux","description":""},{"name":"List.groupBy","description":""},{"name":"List.lookup","description":""},{"name":"List.removeAll","description":""},{"name":"List.drop","description":""},{"name":"List.take","description":""},{"name":"List.takeWhile","description":""},{"name":"List.foldr","description":""},{"name":"List.any","description":""},{"name":"List.all","description":""},{"name":"List.or","description":""},{"name":"List.and","description":""},{"name":"List.zipWith","description":""},{"name":"List.zip","description":""},{"name":"List.unzip","description":""},{"name":"List.rangeAux","description":""},{"name":"List.range","description":""},{"name":"List.iota","description":""},{"name":"List.iotaTR","description":""},{"name":"List.iotaTR.go","description":""},{"name":"List.iota_eq_iotaTR","description":""},{"name":"List.enumFrom","description":""},{"name":"List.enum","description":""},{"name":"List.init","description":""},{"name":"List.intersperse","description":""},{"name":"List.intercalate","description":""},{"name":"List.bind","description":""},{"name":"List.pure","description":""},{"name":"List.lt","description":""},{"name":"List.instLTList","description":""},{"name":"List.hasDecidableLt","description":""},{"name":"List.le","description":""},{"name":"List.instLEList","description":""},{"name":"List.instForAllListDecidableLeInstLEList","description":""},{"name":"List.isPrefixOf","description":"`isPrefixOf l‚ÇÅ l‚ÇÇ` returns `true` Iff `l‚ÇÅ` is a prefix of `l‚ÇÇ`. "},{"name":"List.isSuffixOf","description":"`isSuffixOf l‚ÇÅ l‚ÇÇ` returns `true` Iff `l‚ÇÅ` is a suffix of `l‚ÇÇ`. "},{"name":"List.isEqv","description":""},{"name":"List.beq","description":""},{"name":"List.instBEqList","description":""},{"name":"List.replicate","description":""},{"name":"List.replicateTR","description":""},{"name":"List.replicateTR.loop","description":""},{"name":"List.replicateTR_loop_replicate_eq","description":""},{"name":"List.replicate_eq_replicateTR","description":""},{"name":"List.dropLast","description":""},{"name":"List.length_replicate","description":""},{"name":"List.length_concat","description":""},{"name":"List.length_set","description":""},{"name":"List.length_dropLast_cons","description":""},{"name":"List.length_append","description":""},{"name":"List.length_map","description":""},{"name":"List.length_reverse","description":""},{"name":"List.maximum?","description":""},{"name":"List.minimum?","description":""},{"name":"List.instLawfulBEqListInstBEqList","description":""},{"name":"List.of_concat_eq_concat","description":""},{"name":"List.sizeOf_get_lt","description":""},{"name":"Array.instMembershipArray","description":""},{"name":"Array.sizeOf_get_lt","description":""},{"name":"Array.sizeOf_lt_of_mem","description":""},{"name":"Array.sizeOf_lt_of_mem.aux","description":""},{"name":"Array.sizeOf_get","description":""},{"name":"Array.tacticArray_get_dec","description":""},{"name":"Int","description":""},{"name":"instCoeNatInt","description":""},{"name":"instOfNatInt","description":""},{"name":"Int.instInhabitedInt","description":""},{"name":"Int.negOfNat","description":""},{"name":"Int.neg","description":""},{"name":"Int.subNatNat","description":""},{"name":"Int.add","description":""},{"name":"Int.mul","description":""},{"name":"Int.instNegInt","description":""},{"name":"Int.instAddInt","description":""},{"name":"Int.instMulInt","description":""},{"name":"Int.sub","description":""},{"name":"Int.instSubInt","description":""},{"name":"Int.NonNeg","description":""},{"name":"Int.le","description":""},{"name":"Int.instLEInt","description":""},{"name":"Int.lt","description":""},{"name":"Int.instLTInt","description":""},{"name":"Int.decEq","description":""},{"name":"Int.instDecidableEqInt","description":""},{"name":"Int.decLe","description":""},{"name":"Int.decLt","description":""},{"name":"Int.natAbs","description":""},{"name":"Int.instOfNatInt","description":""},{"name":"Int.div","description":""},{"name":"Int.mod","description":""},{"name":"Int.instDivInt","description":""},{"name":"Int.instModInt","description":""},{"name":"Int.toNat","description":""},{"name":"Int.natMod","description":""},{"name":"Int.pow","description":""},{"name":"Int.instHPowIntNat","description":""},{"name":"Int.instLawfulBEqIntInstBEqInstDecidableEqInt","description":""},{"name":"Std.Format.FlattenBehavior","description":""},{"name":"Std.Format.instInhabitedFlattenBehavior","description":""},{"name":"Std.Format.instBEqFlattenBehavior","description":""},{"name":"Std.Format","description":""},{"name":"Std.instInhabitedFormat","description":""},{"name":"Std.Format.isEmpty","description":""},{"name":"Std.Format.fill","description":""},{"name":"Std.Format.appendEx","description":""},{"name":"Std.Format.groupEx","description":""},{"name":"Std.Format.instAppendFormat","description":""},{"name":"Std.Format.instCoeStringFormat","description":""},{"name":"Std.Format.join","description":""},{"name":"Std.Format.isNil","description":""},{"name":"Std.Format.instInhabitedSpaceResult","description":""},{"name":"Std.Format.MonadPrettyFormat","description":"A monad in which we can pretty-print `Format` objects. "},{"name":"Std.Format.prettyM","description":""},{"name":"Std.Format.bracket","description":""},{"name":"Std.Format.paren","description":""},{"name":"Std.Format.sbracket","description":""},{"name":"Std.Format.bracketFill","description":""},{"name":"Std.Format.defIndent","description":""},{"name":"Std.Format.defUnicode","description":""},{"name":"Std.Format.defWidth","description":""},{"name":"Std.Format.nestD","description":""},{"name":"Std.Format.indentD","description":""},{"name":"Std.Format.instMonadPrettyFormatStateMState","description":""},{"name":"Std.Format.pretty","description":"Pretty-print a `Format` object as a string with expected width `w`. "},{"name":"Std.ToFormat","description":""},{"name":"Std.instToFormatFormat","description":""},{"name":"Std.instToFormatString","description":""},{"name":"Std.Format.joinSep","description":""},{"name":"Std.Format.prefixJoin","description":""},{"name":"Std.Format.joinSuffix","description":""},{"name":"FloatArray","description":""},{"name":"FloatArray.mkEmpty","description":""},{"name":"FloatArray.empty","description":""},{"name":"FloatArray.instInhabitedFloatArray","description":""},{"name":"FloatArray.instEmptyCollectionFloatArray","description":""},{"name":"FloatArray.push","description":""},{"name":"FloatArray.size","description":""},{"name":"FloatArray.uget","description":""},{"name":"FloatArray.get","description":""},{"name":"FloatArray.get!","description":""},{"name":"FloatArray.get?","description":""},{"name":"FloatArray.getOp","description":""},{"name":"FloatArray.uset","description":""},{"name":"FloatArray.set","description":""},{"name":"FloatArray.set!","description":""},{"name":"FloatArray.isEmpty","description":""},{"name":"FloatArray.toList","description":""},{"name":"FloatArray.toList.loop","description":""},{"name":"FloatArray.forInUnsafe","description":""},{"name":"FloatArray.forInUnsafe.loop","description":""},{"name":"FloatArray.forIn","description":""},{"name":"FloatArray.forIn.loop","description":""},{"name":"FloatArray.instForInFloatArrayFloat","description":""},{"name":"FloatArray.foldlMUnsafe","description":""},{"name":"FloatArray.foldlMUnsafe.fold","description":""},{"name":"FloatArray.foldlM","description":""},{"name":"FloatArray.foldlM.loop","description":""},{"name":"FloatArray.foldl","description":""},{"name":"List.toFloatArray","description":""},{"name":"List.toFloatArray.loop","description":""},{"name":"instToStringFloatArray","description":""},{"name":"Array.of_push_eq_push","description":""},{"name":"List.toArray_eq_toArray_eq","description":""},{"name":"Lean.Data.AC.Expr","description":""},{"name":"Lean.Data.AC.instInhabitedExpr","description":""},{"name":"Lean.Data.AC.instReprExpr","description":""},{"name":"Lean.Data.AC.instBEqExpr","description":""},{"name":"Lean.Data.AC.Variable","description":""},{"name":"Lean.Data.AC.Context","description":""},{"name":"Lean.Data.AC.ContextInformation","description":""},{"name":"Lean.Data.AC.EvalInformation","description":""},{"name":"Lean.Data.AC.Context.var","description":""},{"name":"Lean.Data.AC.instContextInformationContext","description":""},{"name":"Lean.Data.AC.instEvalInformationContext","description":""},{"name":"Lean.Data.AC.eval","description":""},{"name":"Lean.Data.AC.Expr.toList","description":""},{"name":"Lean.Data.AC.evalList","description":""},{"name":"Lean.Data.AC.insert","description":""},{"name":"Lean.Data.AC.sort","description":""},{"name":"Lean.Data.AC.sort.loop","description":""},{"name":"Lean.Data.AC.mergeIdem","description":""},{"name":"Lean.Data.AC.mergeIdem.loop","description":""},{"name":"Lean.Data.AC.removeNeutrals","description":""},{"name":"Lean.Data.AC.removeNeutrals.loop","description":""},{"name":"Lean.Data.AC.norm","description":""},{"name":"Lean.Data.AC.List.two_step_induction","description":""},{"name":"Lean.Data.AC.Context.mergeIdem_nonEmpty","description":""},{"name":"Lean.Data.AC.Context.mergeIdem_head","description":""},{"name":"Lean.Data.AC.Context.mergeIdem_head2","description":""},{"name":"Lean.Data.AC.Context.evalList_mergeIdem","description":""},{"name":"Lean.Data.AC.insert_nonEmpty","description":""},{"name":"Lean.Data.AC.Context.sort_loop_nonEmpty","description":""},{"name":"Lean.Data.AC.Context.evalList_insert","description":""},{"name":"Lean.Data.AC.Context.evalList_sort_congr","description":""},{"name":"Lean.Data.AC.Context.evalList_sort_loop_swap","description":""},{"name":"Lean.Data.AC.Context.evalList_sort_cons","description":""},{"name":"Lean.Data.AC.Context.evalList_sort","description":""},{"name":"Lean.Data.AC.Context.toList_nonEmpty","description":""},{"name":"Lean.Data.AC.Context.unwrap_isNeutral","description":""},{"name":"Lean.Data.AC.Context.evalList_removeNeutrals","description":""},{"name":"Lean.Data.AC.Context.evalList_append","description":""},{"name":"Lean.Data.AC.Context.eval_toList","description":""},{"name":"Lean.Data.AC.Context.eval_norm","description":""},{"name":"Lean.Data.AC.Context.eq_of_norm","description":""},{"name":"Std.termF!_","description":""},{"name":"RandomGen","description":""},{"name":"StdGen","description":""},{"name":"instInhabitedStdGen","description":""},{"name":"stdRange","description":""},{"name":"instReprStdGen","description":""},{"name":"stdNext","description":""},{"name":"stdSplit","description":""},{"name":"instRandomGenStdGen","description":""},{"name":"mkStdGen","description":"Return a standard number generator. "},{"name":"randNat","description":"Generate a random natural number in the interval [lo, hi]. "},{"name":"randBool","description":"Generate a random Boolean. "},{"name":"IO.stdGenRef","description":""},{"name":"IO.setRandSeed","description":""},{"name":"IO.rand","description":""},{"name":"Nat.forM","description":""},{"name":"Nat.forM.loop","description":""},{"name":"Nat.forRevM","description":""},{"name":"Nat.forRevM.loop","description":""},{"name":"Nat.foldM","description":""},{"name":"Nat.foldM.loop","description":""},{"name":"Nat.foldRevM","description":""},{"name":"Nat.foldRevM.loop","description":""},{"name":"Nat.allM","description":""},{"name":"Nat.allM.loop","description":""},{"name":"Nat.anyM","description":""},{"name":"Nat.anyM.loop","description":""},{"name":"Lean.version.major","description":""},{"name":"Lean.version.minor","description":""},{"name":"Lean.version.patch","description":""},{"name":"Lean.getGithash","description":""},{"name":"Lean.githash","description":""},{"name":"Lean.version.getIsRelease","description":""},{"name":"Lean.version.isRelease","description":""},{"name":"Lean.version.getSpecialDesc","description":"Additional version description like \"nightly-2018-03-11\" "},{"name":"Lean.version.specialDesc","description":""},{"name":"Lean.versionStringCore","description":""},{"name":"Lean.versionString","description":""},{"name":"Lean.origin","description":""},{"name":"Lean.toolchain","description":""},{"name":"Lean.Internal.isStage0","description":""},{"name":"Lean.isGreek","description":""},{"name":"Lean.isLetterLike","description":""},{"name":"Lean.isNumericSubscript","description":""},{"name":"Lean.isSubScriptAlnum","description":""},{"name":"Lean.isIdFirst","description":""},{"name":"Lean.isIdRest","description":""},{"name":"Lean.idBeginEscape","description":""},{"name":"Lean.idEndEscape","description":""},{"name":"Lean.isIdBeginEscape","description":""},{"name":"Lean.isIdEndEscape","description":""},{"name":"Lean.Name.getRoot","description":""},{"name":"Lean.Name.isInaccessibleUserName","description":""},{"name":"Lean.Name.escapePart","description":""},{"name":"Lean.Name.toStringWithSep","description":""},{"name":"Lean.Name.toStringWithSep.maybeEscape","description":""},{"name":"Lean.Name.toString","description":""},{"name":"Lean.Name.toString.maybePseudoSyntax","description":""},{"name":"Lean.Name.instToStringName","description":""},{"name":"Lean.Name.reprPrec","description":""},{"name":"Lean.Name.instReprName","description":""},{"name":"Lean.Name.instReprSyntax","description":""},{"name":"Lean.Name.capitalize","description":""},{"name":"Lean.Name.replacePrefix","description":""},{"name":"Lean.Name.modifyBase","description":"Remove macros scopes, apply `f`, and put them back "},{"name":"Lean.Name.appendAfter","description":""},{"name":"Lean.Name.appendIndexAfter","description":""},{"name":"Lean.Name.appendBefore","description":""},{"name":"Lean.NameGenerator","description":""},{"name":"Lean.instInhabitedNameGenerator","description":""},{"name":"Lean.NameGenerator.curr","description":""},{"name":"Lean.NameGenerator.next","description":""},{"name":"Lean.NameGenerator.mkChild","description":""},{"name":"Lean.MonadNameGenerator","description":""},{"name":"Lean.mkFreshId","description":""},{"name":"Lean.monadNameGeneratorLift","description":""},{"name":"Lean.Syntax.structEq","description":""},{"name":"Lean.Syntax.instBEqSyntax","description":""},{"name":"Lean.Syntax.getTailInfo?","description":""},{"name":"Lean.Syntax.getTailInfo","description":""},{"name":"Lean.Syntax.getTrailingSize","description":""},{"name":"Lean.Syntax.getSubstring?","description":"Return substring of original input covering `stx`.\n  Result is meaningful only if all involved `SourceInfo.original`s refer to the same string (as is the case after parsing). "},{"name":"Lean.Syntax.setTailInfoAux","description":""},{"name":"Lean.Syntax.setTailInfo","description":""},{"name":"Lean.Syntax.unsetTrailing","description":""},{"name":"Lean.Syntax.setHeadInfoAux","description":""},{"name":"Lean.Syntax.setHeadInfo","description":""},{"name":"Lean.Syntax.setInfo","description":""},{"name":"Lean.Syntax.getHead?","description":"Return the first atom/identifier that has position information "},{"name":"Lean.Syntax.copyHeadTailInfoFrom","description":""},{"name":"Lean.Syntax.mkSynthetic","description":"Ensure head position is synthetic. The server regards syntax as \"original\" only if both head and tail info are `original`. "},{"name":"Lean.withHeadRefOnly","description":"Use the head atom/identifier of the current `ref` as the `ref` "},{"name":"Lean.mkNode","description":""},{"name":"Lean.Module","description":""},{"name":"Lean.expandMacros","description":"Expand all macros in the given syntax "},{"name":"Lean.mkIdentFrom","description":"Create an identifier copying the position from `src`.\n  To refer to a specific constant, use `mkCIdentFrom` instead. "},{"name":"Lean.mkIdentFromRef","description":""},{"name":"Lean.mkCIdentFrom","description":"Create an identifier referring to a constant `c` copying the position from `src`.\n  This variant of `mkIdentFrom` makes sure that the identifier cannot accidentally\n  be captured. "},{"name":"Lean.mkCIdentFromRef","description":""},{"name":"Lean.mkCIdent","description":""},{"name":"Lean.mkIdent","description":""},{"name":"Lean.mkNullNode","description":""},{"name":"Lean.mkGroupNode","description":""},{"name":"Lean.mkSepArray","description":""},{"name":"Lean.mkOptionalNode","description":""},{"name":"Lean.mkHole","description":""},{"name":"Lean.Syntax.mkSep","description":""},{"name":"Lean.Syntax.SepArray.ofElems","description":""},{"name":"Lean.Syntax.SepArray.ofElemsUsingRef","description":""},{"name":"Lean.Syntax.instCoeArraySyntaxSepArray","description":""},{"name":"Lean.Syntax.mkApp","description":"Create syntax representing a Lean term application, but avoid degenerate empty applications. "},{"name":"Lean.Syntax.mkCApp","description":""},{"name":"Lean.Syntax.mkLit","description":""},{"name":"Lean.Syntax.mkStrLit","description":""},{"name":"Lean.Syntax.mkNumLit","description":""},{"name":"Lean.Syntax.mkScientificLit","description":""},{"name":"Lean.Syntax.mkNameLit","description":""},{"name":"Lean.Syntax.decodeNatLitVal?","description":""},{"name":"Lean.Syntax.isLit?","description":""},{"name":"Lean.Syntax.isNatLit?","description":""},{"name":"Lean.Syntax.isFieldIdx?","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeAfterExp","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeExp","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeAfterDot","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decode","description":""},{"name":"Lean.Syntax.isScientificLit?","description":""},{"name":"Lean.Syntax.isIdOrAtom?","description":""},{"name":"Lean.Syntax.toNat","description":""},{"name":"Lean.Syntax.decodeQuotedChar","description":""},{"name":"Lean.Syntax.decodeStrLitAux","description":""},{"name":"Lean.Syntax.decodeStrLit","description":""},{"name":"Lean.Syntax.isStrLit?","description":""},{"name":"Lean.Syntax.decodeCharLit","description":""},{"name":"Lean.Syntax.isCharLit?","description":""},{"name":"Lean.Syntax.splitNameLit","description":"Split a name literal (without the backtick) into its dot-separated components. For example,\n`foo.bla.¬´bo.o¬ª` ‚Ü¶ `[\"foo\", \"bla\", \"¬´bo.o¬ª\"]`. If the literal cannot be parsed, return `[]`. "},{"name":"Lean.Syntax.decodeNameLit","description":""},{"name":"Lean.Syntax.isNameLit?","description":""},{"name":"Lean.Syntax.hasArgs","description":""},{"name":"Lean.Syntax.isAtom","description":""},{"name":"Lean.Syntax.isToken","description":""},{"name":"Lean.Syntax.isNone","description":""},{"name":"Lean.Syntax.getOptional?","description":""},{"name":"Lean.Syntax.getOptionalIdent?","description":""},{"name":"Lean.Syntax.findAux","description":""},{"name":"Lean.Syntax.find?","description":""},{"name":"Lean.Quote","description":"Reflect a runtime datum back to surface syntax (best-effort). "},{"name":"Lean.instQuoteSyntax","description":""},{"name":"Lean.instQuoteBool","description":""},{"name":"Lean.instQuoteString","description":""},{"name":"Lean.instQuoteNat","description":""},{"name":"Lean.instQuoteSubstring","description":""},{"name":"Lean.instQuoteName","description":""},{"name":"Lean.instQuoteProd","description":""},{"name":"Lean.instQuoteList","description":""},{"name":"Lean.instQuoteArray","description":""},{"name":"Lean.Option.hasQuote","description":""},{"name":"Lean.evalPrec","description":""},{"name":"Lean.termEval_prec_","description":""},{"name":"Lean.evalPrio","description":""},{"name":"Lean.termEval_prio_","description":""},{"name":"Lean.evalOptPrio","description":""},{"name":"Array.getSepElems","description":""},{"name":"Array.filterSepElemsM","description":""},{"name":"Array.filterSepElems","description":""},{"name":"Array.mapSepElemsM","description":""},{"name":"Array.mapSepElems","description":""},{"name":"Lean.Syntax.SepArray.getElems","description":""},{"name":"Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax","description":""},{"name":"autoParam","description":"Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\n  the given tactic.\n  Like `optParam`, this gadget only affects elaboration.\n  For example, the tactic will *not* be invoked during type class resolution. "},{"name":"Lean.Syntax.isInterpolatedStrLit?","description":""},{"name":"Lean.Syntax.expandInterpolatedStrChunks","description":""},{"name":"Lean.Syntax.expandInterpolatedStr","description":""},{"name":"Lean.Syntax.getSepArgs","description":""},{"name":"Lean.Meta.TransparencyMode","description":""},{"name":"Lean.Meta.instInhabitedTransparencyMode","description":""},{"name":"Lean.Meta.instBEqTransparencyMode","description":""},{"name":"Lean.Meta.instReprTransparencyMode","description":""},{"name":"Lean.Meta.EtaStructMode","description":""},{"name":"Lean.Meta.instInhabitedEtaStructMode","description":""},{"name":"Lean.Meta.instBEqEtaStructMode","description":""},{"name":"Lean.Meta.instReprEtaStructMode","description":""},{"name":"Lean.Meta.DSimp.Config","description":""},{"name":"Lean.Meta.DSimp.instInhabitedConfig","description":""},{"name":"Lean.Meta.DSimp.instBEqConfig","description":""},{"name":"Lean.Meta.DSimp.instReprConfig","description":""},{"name":"Lean.Meta.Simp.defaultMaxSteps","description":""},{"name":"Lean.Meta.Simp.Config","description":""},{"name":"Lean.Meta.Simp.instInhabitedConfig","description":""},{"name":"Lean.Meta.Simp.instBEqConfig","description":""},{"name":"Lean.Meta.Simp.instReprConfig","description":""},{"name":"Lean.Meta.Simp.ConfigCtx","description":""},{"name":"Lean.Meta.Simp.neutralConfig","description":""},{"name":"Lean.Meta.Rewrite.Config","description":""},{"name":"Lean.Parser.Tactic.tacticErw__","description":""},{"name":"Lean.Parser.Tactic.simpAllKind","description":""},{"name":"Lean.Parser.Tactic.dsimpKind","description":""},{"name":"Lean.Parser.Tactic.commandDeclare_simp_like_tactic______","description":""},{"name":"Lean.Parser.Tactic.simpAutoUnfold","description":""},{"name":"Lean.Parser.Tactic.simpArith","description":""},{"name":"Lean.Parser.Tactic.simpArithAutoUnfold","description":""},{"name":"Lean.Parser.Tactic.simpAllAutoUnfold","description":""},{"name":"Lean.Parser.Tactic.simpAllArith","description":""},{"name":"Lean.Parser.Tactic.simpAllArithAutoUnfold","description":""},{"name":"Lean.Parser.Tactic.dsimpAutoUnfold","description":""},{"name":"Lean.¬´termMacro.trace[__]_¬ª","description":""},{"name":"Lean.binderIdent","description":""},{"name":"Lean.unbracketedExplicitBinders","description":""},{"name":"Lean.bracketedExplicitBinders","description":""},{"name":"Lean.explicitBinders","description":""},{"name":"Lean.expandExplicitBindersAux","description":""},{"name":"Lean.expandExplicitBindersAux.loop","description":""},{"name":"Lean.expandBrackedBindersAux","description":""},{"name":"Lean.expandBrackedBindersAux.loop","description":""},{"name":"Lean.expandExplicitBinders","description":""},{"name":"Lean.expandBrackedBinders","description":""},{"name":"Lean.unifConstraint","description":""},{"name":"Lean.unifConstraintElem","description":""},{"name":"Lean.¬´command_Unif_hint___Where_|-‚ä¢_¬ª","description":""},{"name":"¬´term‚àÉ_,_¬ª","description":""},{"name":"¬´termExists_,_¬ª","description":""},{"name":"¬´termŒ£_,_¬ª","description":""},{"name":"¬´termŒ£'_,_¬ª","description":""},{"name":"¬´term_√ó__1¬ª","description":""},{"name":"¬´term_√ó'_¬ª","description":""},{"name":"calcStep","description":""},{"name":"calc","description":""},{"name":"tacticCalc_","description":""},{"name":"unexpandUnit","description":""},{"name":"unexpandListNil","description":""},{"name":"unexpandListCons","description":""},{"name":"unexpandListToArray","description":""},{"name":"unexpandProdMk","description":""},{"name":"unexpandIte","description":""},{"name":"unexpandSorryAx","description":""},{"name":"unexpandEqNDRec","description":""},{"name":"unexpandEqRec","description":""},{"name":"unexpandExists","description":""},{"name":"unexpandSigma","description":""},{"name":"unexpandPSigma","description":""},{"name":"unexpandSubtype","description":""},{"name":"tacticFunext__","description":"Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying new the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h‚ÇÅ ... h‚Çô` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat √ó Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n"},{"name":"¬´command_ClassAbbrev__:_:=__,¬ª","description":""},{"name":"¬´tactic¬∑.__;_¬ª","description":"`¬∑ tac` focuses on the main goal and tries to solve it using `tac`, or else fails. "},{"name":"solve","description":"Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n"},{"name":"Lean.Loop","description":""},{"name":"Lean.Loop.forIn","description":""},{"name":"Lean.Loop.forIn.loop","description":""},{"name":"Lean.instForInLoopUnit","description":""},{"name":"Lean.doElemRepeat_","description":""},{"name":"Lean.doElemWhile_Do_","description":""},{"name":"Lean.doElemRepeat_Until_","description":""},{"name":"Lean.¬´term_Matches_|¬ª","description":""},{"name":"termS!_","description":""},{"name":"ToString","description":""},{"name":"instToStringIdType","description":""},{"name":"instToStringId","description":""},{"name":"instToStringString","description":""},{"name":"instToStringSubstring","description":""},{"name":"instToStringIterator","description":""},{"name":"instToStringBool","description":""},{"name":"instToStringDecidable","description":""},{"name":"List.toStringAux","description":""},{"name":"List.toString","description":""},{"name":"instToStringList","description":""},{"name":"instToStringPUnit","description":""},{"name":"instToStringULift","description":""},{"name":"instToStringUnit","description":""},{"name":"instToStringNat","description":""},{"name":"instToStringPos","description":""},{"name":"instToStringInt","description":""},{"name":"instToStringChar","description":""},{"name":"instToStringFin","description":""},{"name":"instToStringUInt8","description":""},{"name":"instToStringUInt16","description":""},{"name":"instToStringUInt32","description":""},{"name":"instToStringUInt64","description":""},{"name":"instToStringUSize","description":""},{"name":"instToStringFormat","description":""},{"name":"addParenHeuristic","description":""},{"name":"instToStringOption","description":""},{"name":"instToStringSum","description":""},{"name":"instToStringProd","description":""},{"name":"instToStringSigma","description":""},{"name":"instToStringSubtype","description":""},{"name":"String.toInt?","description":""},{"name":"String.isInt","description":""},{"name":"String.toInt!","description":""},{"name":"instToStringExcept","description":""},{"name":"instReprExcept","description":""},{"name":"System.Platform.getIsWindows","description":""},{"name":"System.Platform.getIsOSX","description":""},{"name":"System.Platform.getIsEmscripten","description":""},{"name":"System.Platform.isWindows","description":""},{"name":"System.Platform.isOSX","description":""},{"name":"System.Platform.isEmscripten","description":""},{"name":"Lean.Syntax.formatStxAux","description":""},{"name":"Lean.Syntax.formatStx","description":""},{"name":"Lean.Syntax.instToFormatSyntax","description":""},{"name":"Lean.Syntax.instToStringSyntax","description":""},{"name":"Nat.foldAux","description":""},{"name":"Nat.fold","description":""},{"name":"Nat.foldRev","description":""},{"name":"Nat.foldRev.loop","description":""},{"name":"Nat.anyAux","description":""},{"name":"Nat.any","description":""},{"name":"Nat.all","description":""},{"name":"Nat.repeat","description":""},{"name":"Nat.repeat.loop","description":""},{"name":"Nat.blt","description":""},{"name":"Nat.zero_eq","description":""},{"name":"Nat.add_eq","description":""},{"name":"Nat.mul_eq","description":""},{"name":"Nat.sub_eq","description":""},{"name":"Nat.lt_eq","description":""},{"name":"Nat.le_eq","description":""},{"name":"Nat.beq_refl","description":""},{"name":"Nat.beq_eq","description":""},{"name":"Nat.ble_eq","description":""},{"name":"Nat.blt_eq","description":""},{"name":"Nat.instLawfulBEqNatInstBEqNat","description":""},{"name":"Nat.beq_eq_true_eq","description":""},{"name":"Nat.not_beq_eq_true_eq","description":""},{"name":"Nat.zero_add","description":""},{"name":"Nat.succ_add","description":""},{"name":"Nat.add_succ","description":""},{"name":"Nat.add_one","description":""},{"name":"Nat.succ_eq_add_one","description":""},{"name":"Nat.add_comm","description":""},{"name":"Nat.add_assoc","description":""},{"name":"Nat.add_left_comm","description":""},{"name":"Nat.add_right_comm","description":""},{"name":"Nat.add_left_cancel","description":""},{"name":"Nat.add_right_cancel","description":""},{"name":"Nat.mul_zero","description":""},{"name":"Nat.mul_succ","description":""},{"name":"Nat.zero_mul","description":""},{"name":"Nat.succ_mul","description":""},{"name":"Nat.mul_comm","description":""},{"name":"Nat.mul_one","description":""},{"name":"Nat.one_mul","description":""},{"name":"Nat.left_distrib","description":""},{"name":"Nat.right_distrib","description":""},{"name":"Nat.mul_add","description":""},{"name":"Nat.add_mul","description":""},{"name":"Nat.mul_assoc","description":""},{"name":"Nat.mul_left_comm","description":""},{"name":"Nat.succ_lt_succ","description":""},{"name":"Nat.lt_succ_of_le","description":""},{"name":"Nat.sub_zero","description":""},{"name":"Nat.succ_sub_succ_eq_sub","description":""},{"name":"Nat.pred_le","description":""},{"name":"Nat.pred_lt","description":""},{"name":"Nat.sub_le","description":""},{"name":"Nat.sub_lt","description":""},{"name":"Nat.sub_succ","description":""},{"name":"Nat.succ_sub_succ","description":""},{"name":"Nat.sub_self","description":""},{"name":"Nat.lt_of_lt_of_le","description":""},{"name":"Nat.lt_of_lt_of_eq","description":""},{"name":"Nat.instTransNatLtInstLTNat","description":""},{"name":"Nat.instTransNatLeInstLENat","description":""},{"name":"Nat.instTransNatLtInstLTNatLeInstLENat","description":""},{"name":"Nat.instTransNatLeInstLENatLtInstLTNat","description":""},{"name":"Nat.le_of_eq","description":""},{"name":"Nat.le_of_succ_le","description":""},{"name":"Nat.le_of_lt","description":""},{"name":"Nat.lt.step","description":""},{"name":"Nat.eq_zero_or_pos","description":""},{"name":"Nat.lt.base","description":""},{"name":"Nat.lt_succ_self","description":""},{"name":"Nat.le_total","description":""},{"name":"Nat.eq_zero_of_le_zero","description":""},{"name":"Nat.lt_of_succ_lt","description":""},{"name":"Nat.lt_of_succ_lt_succ","description":""},{"name":"Nat.lt_of_succ_le","description":""},{"name":"Nat.succ_le_of_lt","description":""},{"name":"Nat.zero_lt_of_lt","description":""},{"name":"Nat.zero_lt_of_ne_zero","description":""},{"name":"Nat.ne_of_lt","description":""},{"name":"Nat.le_or_eq_or_le_succ","description":""},{"name":"Nat.le_add_right","description":""},{"name":"Nat.le_add_left","description":""},{"name":"Nat.le.dest","description":""},{"name":"Nat.le.intro","description":""},{"name":"Nat.not_le_of_gt","description":""},{"name":"Nat.gt_of_not_le","description":""},{"name":"Nat.ge_of_not_lt","description":""},{"name":"Nat.instAntisymmNatLeInstLENat","description":""},{"name":"Nat.instAntisymmNatNotLtInstLTNat","description":""},{"name":"Nat.add_le_add_left","description":""},{"name":"Nat.add_le_add_right","description":""},{"name":"Nat.add_lt_add_left","description":""},{"name":"Nat.add_lt_add_right","description":""},{"name":"Nat.zero_lt_one","description":""},{"name":"Nat.add_le_add","description":""},{"name":"Nat.add_lt_add","description":""},{"name":"Nat.le_of_add_le_add_left","description":""},{"name":"Nat.le_of_add_le_add_right","description":""},{"name":"Nat.ctor_eq_zero","description":""},{"name":"Nat.one_ne_zero","description":""},{"name":"Nat.zero_ne_one","description":""},{"name":"Nat.succ_ne_zero","description":""},{"name":"Nat.mul_le_mul_left","description":""},{"name":"Nat.mul_le_mul_right","description":""},{"name":"Nat.mul_le_mul","description":""},{"name":"Nat.mul_lt_mul_of_pos_left","description":""},{"name":"Nat.mul_lt_mul_of_pos_right","description":""},{"name":"Nat.mul_pos","description":""},{"name":"Nat.le_of_mul_le_mul_left","description":""},{"name":"Nat.eq_of_mul_eq_mul_left","description":""},{"name":"Nat.eq_of_mul_eq_mul_right","description":""},{"name":"Nat.pow_succ","description":""},{"name":"Nat.pow_zero","description":""},{"name":"Nat.pow_le_pow_of_le_left","description":""},{"name":"Nat.pow_le_pow_of_le_right","description":""},{"name":"Nat.pos_pow_of_pos","description":""},{"name":"Nat.min","description":""},{"name":"Nat.max","description":""},{"name":"Nat.not_eq_zero_of_lt","description":""},{"name":"Nat.pred_lt'","description":""},{"name":"Nat.add_sub_self_left","description":""},{"name":"Nat.add_sub_self_right","description":""},{"name":"Nat.sub_le_succ_sub","description":""},{"name":"Nat.zero_lt_sub_of_lt","description":""},{"name":"Nat.sub_succ_lt_self","description":""},{"name":"Nat.succ_pred","description":""},{"name":"Nat.sub_ne_zero_of_lt","description":""},{"name":"Nat.add_sub_of_le","description":""},{"name":"Nat.sub_add_cancel","description":""},{"name":"Nat.add_sub_add_right","description":""},{"name":"Nat.add_sub_add_left","description":""},{"name":"Nat.add_sub_cancel","description":""},{"name":"Nat.add_sub_cancel_left","description":""},{"name":"Nat.add_sub_assoc","description":""},{"name":"Nat.eq_add_of_sub_eq","description":""},{"name":"Nat.sub_eq_of_eq_add","description":""},{"name":"Nat.le_add_of_sub_le","description":""},{"name":"Nat.zero_sub","description":""},{"name":"Nat.sub_self_add","description":""},{"name":"Nat.sub_eq_zero_of_le","description":""},{"name":"Nat.sub_le_of_le_add","description":""},{"name":"Nat.add_le_of_le_sub","description":""},{"name":"Nat.le_sub_of_add_le","description":""},{"name":"Nat.add_lt_of_lt_sub","description":""},{"name":"Nat.lt_sub_of_add_lt","description":""},{"name":"Nat.pred_zero","description":""},{"name":"Nat.pred_succ","description":""},{"name":"Nat.sub.elim","description":""},{"name":"Nat.mul_pred_left","description":""},{"name":"Nat.mul_pred_right","description":""},{"name":"Nat.sub_sub","description":""},{"name":"Nat.mul_sub_right_distrib","description":""},{"name":"Nat.mul_sub_left_distrib","description":""},{"name":"Nat.not_le_eq","description":""},{"name":"Nat.not_ge_eq","description":""},{"name":"Nat.not_lt_eq","description":""},{"name":"Nat.not_gt_eq","description":""},{"name":"Prod.foldI","description":""},{"name":"Prod.anyI","description":""},{"name":"Prod.allI","description":""},{"name":"Fin.sizeOf","description":""},{"name":"UInt8.sizeOf","description":""},{"name":"UInt16.sizeOf","description":""},{"name":"UInt32.sizeOf","description":""},{"name":"UInt64.sizeOf","description":""},{"name":"USize.sizeOf","description":""},{"name":"Char.sizeOf","description":""},{"name":"Subtype.sizeOf","description":""},{"name":"ByteArray","description":""},{"name":"ByteArray.mkEmpty","description":""},{"name":"ByteArray.empty","description":""},{"name":"ByteArray.instInhabitedByteArray","description":""},{"name":"ByteArray.instEmptyCollectionByteArray","description":""},{"name":"ByteArray.push","description":""},{"name":"ByteArray.size","description":""},{"name":"ByteArray.uget","description":""},{"name":"ByteArray.get!","description":""},{"name":"ByteArray.get","description":""},{"name":"ByteArray.getOp","description":""},{"name":"ByteArray.set!","description":""},{"name":"ByteArray.set","description":""},{"name":"ByteArray.uset","description":""},{"name":"ByteArray.isEmpty","description":""},{"name":"ByteArray.copySlice","description":"Copy the slice at `[srcOff, srcOff + len)` in `src` to `[destOff, destOff + len)` in `dest`, growing `dest` if necessary.\n  If `exact` is `false`, the capacity will be doubled when grown. "},{"name":"ByteArray.extract","description":""},{"name":"ByteArray.append","description":""},{"name":"ByteArray.instAppendByteArray","description":""},{"name":"ByteArray.toList","description":""},{"name":"ByteArray.toList.loop","description":""},{"name":"ByteArray.findIdx?","description":""},{"name":"ByteArray.findIdx?.loop","description":""},{"name":"ByteArray.forInUnsafe","description":""},{"name":"ByteArray.forInUnsafe.loop","description":""},{"name":"ByteArray.forIn","description":""},{"name":"ByteArray.forIn.loop","description":""},{"name":"ByteArray.instForInByteArrayUInt8","description":""},{"name":"ByteArray.foldlMUnsafe","description":""},{"name":"ByteArray.foldlMUnsafe.fold","description":""},{"name":"ByteArray.foldlM","description":""},{"name":"ByteArray.foldlM.loop","description":""},{"name":"ByteArray.foldl","description":""},{"name":"List.toByteArray","description":""},{"name":"List.toByteArray.loop","description":""},{"name":"instToStringByteArray","description":""},{"name":"ByteArray.toUInt64LE!","description":"Interpret a `ByteArray` of size 8 as a little-endian `UInt64`. "},{"name":"ByteArray.toUInt64BE!","description":"Interpret a `ByteArray` of size 8 as a big-endian `UInt64`. "},{"name":"Subarray","description":""},{"name":"Subarray.size","description":""},{"name":"Subarray.get","description":""},{"name":"Subarray.getD","description":""},{"name":"Subarray.get!","description":""},{"name":"Subarray.getOp","description":""},{"name":"Subarray.popFront","description":""},{"name":"Subarray.forInUnsafe","description":""},{"name":"Subarray.forInUnsafe.loop","description":""},{"name":"Subarray.forIn","description":""},{"name":"Subarray.instForInSubarray","description":""},{"name":"Subarray.foldlM","description":""},{"name":"Subarray.foldrM","description":""},{"name":"Subarray.anyM","description":""},{"name":"Subarray.allM","description":""},{"name":"Subarray.forM","description":""},{"name":"Subarray.forRevM","description":""},{"name":"Subarray.foldl","description":""},{"name":"Subarray.foldr","description":""},{"name":"Subarray.any","description":""},{"name":"Subarray.all","description":""},{"name":"Array.toSubarray","description":""},{"name":"Array.ofSubarray","description":""},{"name":"Array.extract","description":""},{"name":"Array.instCoeSubarrayArray","description":""},{"name":"Array.¬´term__[_:_]¬ª","description":""},{"name":"Array.¬´term__[_:]¬ª","description":""},{"name":"Array.¬´term__[:_]¬ª","description":""},{"name":"Subarray.toArray","description":""},{"name":"instAppendSubarray","description":""},{"name":"instReprSubarray","description":""},{"name":"instToStringSubarray","description":""},{"name":"Lean.Parser.Syntax.addPrec","description":""},{"name":"Lean.Parser.Syntax.subPrec","description":""},{"name":"Lean.Parser.Syntax.addPrio","description":""},{"name":"Lean.Parser.Syntax.subPrio","description":""},{"name":"precMax","description":""},{"name":"precArg","description":""},{"name":"precLead","description":""},{"name":"¬´prec(_)¬ª","description":""},{"name":"precMin","description":""},{"name":"precMin1","description":""},{"name":"termMax_prec","description":""},{"name":"prioDefault","description":""},{"name":"prioLow","description":""},{"name":"prioMid","description":""},{"name":"prioHigh","description":""},{"name":"¬´prio(_)¬ª","description":""},{"name":"¬´stx_+¬ª","description":""},{"name":"¬´stx_*¬ª","description":""},{"name":"stx_?","description":""},{"name":"¬´stx_<|>_¬ª","description":""},{"name":"¬´stx_,*¬ª","description":""},{"name":"¬´stx_,+¬ª","description":""},{"name":"¬´stx_,*,?¬ª","description":""},{"name":"¬´stx_,+,?¬ª","description":""},{"name":"stx!_","description":""},{"name":"rawNatLit","description":""},{"name":"¬´term_‚àò_¬ª","description":""},{"name":"¬´term_√ó_¬ª","description":""},{"name":"¬´term_|||_¬ª","description":""},{"name":"¬´term_^^^_¬ª","description":""},{"name":"¬´term_&&&_¬ª","description":""},{"name":"¬´term_+_¬ª","description":""},{"name":"¬´term_-_¬ª","description":""},{"name":"¬´term_*_¬ª","description":""},{"name":"¬´term_/_¬ª","description":""},{"name":"¬´term_%_¬ª","description":""},{"name":"¬´term_<<<_¬ª","description":""},{"name":"¬´term_>>>_¬ª","description":""},{"name":"¬´term_^_¬ª","description":""},{"name":"¬´term_++_¬ª","description":""},{"name":"¬´term-_¬ª","description":""},{"name":"¬´term~~~_¬ª","description":""},{"name":"¬´term_<=_¬ª","description":""},{"name":"¬´term_‚â§_¬ª","description":""},{"name":"¬´term_<_¬ª","description":""},{"name":"¬´term_>=_¬ª","description":""},{"name":"¬´term_‚â•_¬ª","description":""},{"name":"¬´term_>_¬ª","description":""},{"name":"¬´term_=_¬ª","description":""},{"name":"¬´term_==_¬ª","description":""},{"name":"¬´term_/\\_¬ª","description":""},{"name":"¬´term_‚àß_¬ª","description":""},{"name":"¬´term_\\/_¬ª","description":""},{"name":"¬´term_‚à®_¬ª","description":""},{"name":"¬´term¬¨_¬ª","description":""},{"name":"¬´term_&&_¬ª","description":""},{"name":"¬´term_||_¬ª","description":""},{"name":"term!_","description":""},{"name":"¬´term_‚àà_¬ª","description":""},{"name":"¬´term_‚àâ_¬ª","description":""},{"name":"¬´term_::_¬ª","description":""},{"name":"¬´term_<|>_¬ª","description":""},{"name":"¬´term_>>_¬ª","description":""},{"name":"¬´term_>>=_¬ª","description":""},{"name":"¬´term_<*>_¬ª","description":""},{"name":"¬´term_<*_¬ª","description":""},{"name":"¬´term_*>_¬ª","description":""},{"name":"¬´term_<$>_¬ª","description":""},{"name":"termDepIfThenElse","description":""},{"name":"termIfThenElse","description":""},{"name":"¬´termIfLet_:=_Then_Else_¬ª","description":""},{"name":"boolIfThenElse","description":""},{"name":"¬´term_<|_¬ª","description":""},{"name":"¬´term_|>_¬ª","description":""},{"name":"¬´term_$__¬ª","description":""},{"name":"¬´term{__:_//_}¬ª","description":""},{"name":"termWithout_expected_type_","description":""},{"name":"¬´term[_]¬ª","description":""},{"name":"¬´term%[_|_]¬ª","description":""},{"name":"Lean.termThis","description":"Special identifier introduced by \"anonymous\" `have : ...`, `suffices p ...` etc. "},{"name":"Lean.rawStx.quot","description":""}]